<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LDraw Model Viewer v5</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;800&display=swap');
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --panel: #16161a; --border: #2a2a30;
    --accent: #ffcc00; --accent-mr: #00ddff; --text: #e8e8ec; --muted: #6b6b78;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Syne', sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
  header { display: flex; align-items: center; justify-content: space-between; padding: 12px 24px; border-bottom: 1px solid var(--border); background: var(--panel); flex-shrink: 0; }
  .logo { display: flex; align-items: center; gap: 10px; }
  .logo-brick { width: 28px; height: 20px; background: var(--accent); border-radius: 2px; position: relative; }
  .logo-brick::before, .logo-brick::after { content: ''; position: absolute; top: -7px; width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
  .logo-brick::before { left: 4px; } .logo-brick::after { right: 4px; }
  .logo h1 { font-size: 16px; font-weight: 800; letter-spacing: .05em; text-transform: uppercase; }
  .logo span { color: var(--accent); }
  .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .btn { font-family: 'Space Mono', monospace; font-size: 11px; padding: 7px 14px; border-radius: 4px; border: 1px solid var(--border); background: transparent; color: var(--text); cursor: pointer; text-transform: uppercase; letter-spacing: .08em; transition: all .15s; white-space: nowrap; }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  /* Destructive / exit actions — red idle, red-fill on hover */
  .btn.btn-danger          { border-color: #ff4444; color: #ff4444; background: transparent; }
  .btn.btn-danger:hover    { border-color: #ff4444; color: var(--bg); background: #ff4444; }
  .btn.btn-danger:disabled { border-color: var(--border); color: var(--muted); background: transparent; cursor: not-allowed; }
  .btn.primary { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
  .btn.primary:hover { background: #ffd633; }
  /* MR button gets a cyan accent */
  .btn.mr-btn { border-color: var(--accent-mr); color: var(--accent-mr); }
  .btn.mr-btn:hover { background: var(--accent-mr); color: #000; }
  .btn.mr-btn:disabled { border-color: var(--border); color: var(--muted); cursor: not-allowed; }
  .workspace { flex: 1; display: flex; overflow: hidden; }
  #canvas-container { flex: 1; position: relative; background: radial-gradient(ellipse at center, #1a1a2e 0%, #0e0e10 70%); }
  canvas { display: block; }
  .sidebar { width: 220px; background: var(--panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; flex-shrink: 0; overflow-y: auto; }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); }
  .sidebar-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: .15em; color: var(--muted); margin-bottom: 12px; }
  .info-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 6px; font-family: 'Space Mono', monospace; }
  .info-row .label { color: var(--muted); }
  .info-row .value { color: var(--text); }
  .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
  .toggle-label { font-size: 11px; font-family: 'Space Mono', monospace; text-transform: uppercase; letter-spacing: .05em; }
  .toggle { width: 34px; height: 18px; background: var(--border); border-radius: 9px; cursor: pointer; position: relative; transition: background .2s; }
  .toggle.on { background: var(--accent); }
  .toggle::after { content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: left .2s; }
  .toggle.on::after { left: 18px; }
  .hint { font-size: 10px; color: var(--muted); font-family: 'Space Mono', monospace; line-height: 1.8; }
  .hint b { color: var(--text); }
  .url-input { width: 100%; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 7px 8px; color: var(--text); font-family: 'Space Mono', monospace; font-size: 10px; margin-bottom: 6px; outline: none; }
  .url-input:focus { border-color: var(--accent); }
  .url-input::placeholder { color: var(--muted); }
  #drop-zone { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; cursor: pointer; }
  .drop-icon { width: 80px; height: 56px; border: 2px dashed var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; transition: all .2s; }
  .drop-zone-brick { width: 36px; height: 24px; background: var(--border); border-radius: 2px; position: relative; transition: background .2s; }
  .drop-zone-brick::before, .drop-zone-brick::after { content: ''; position: absolute; top: -9px; width: 10px; height: 10px; background: var(--border); border-radius: 50%; transition: background .2s; }
  .drop-zone-brick::before { left: 5px; } .drop-zone-brick::after { right: 5px; }
  .drop-text { text-align: center; }
  .drop-text h2 { font-size: 15px; font-weight: 600; }
  .drop-text p { font-size: 11px; color: var(--muted); font-family: 'Space Mono', monospace; margin-top: 4px; }
  #drop-zone.dragging .drop-icon, #drop-zone:hover .drop-icon { border-color: var(--accent); }
  #drop-zone.dragging .drop-zone-brick, #drop-zone:hover .drop-zone-brick,
  #drop-zone.dragging .drop-zone-brick::before, #drop-zone.dragging .drop-zone-brick::after,
  #drop-zone:hover .drop-zone-brick::before, #drop-zone:hover .drop-zone-brick::after { background: var(--accent); }
  #loading-overlay { display: none; position: absolute; inset: 0; background: rgba(14,14,16,.8); align-items: center; justify-content: center; flex-direction: column; gap: 14px; }
  #loading-overlay.visible { display: flex; }
  .spinner { width: 32px; height: 32px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-family: 'Space Mono', monospace; font-size: 12px; color: var(--text); }
  .loading-sub { font-family: 'Space Mono', monospace; font-size: 10px; color: var(--muted); max-width: 280px; text-align: center; line-height: 1.6; }
  #status { position: absolute; bottom: 16px; left: 16px; font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted); pointer-events: none; }
  /* Mode badge — shown in VR/MR so user knows what mode they entered */
  #mode-badge { position: absolute; top: 16px; right: 16px; font-family: 'Space Mono', monospace; font-size: 10px; padding: 4px 10px; border-radius: 3px; display: none; pointer-events: none; }
  #mode-badge.vr { display: block; background: rgba(255,204,0,.15); border: 1px solid var(--accent); color: var(--accent); }
  #mode-badge.mr { display: block; background: rgba(0,221,255,.15); border: 1px solid var(--accent-mr); color: var(--accent-mr); }
  #file-input { display: none; }
  .error-banner { display: none; position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: #2a1010; border: 1px solid #663333; border-radius: 6px; padding: 12px 20px; max-width: 420px; width: 90%; z-index: 10; }
  .error-banner.visible { display: flex; align-items: flex-start; gap: 10px; }
  .error-banner-text { flex: 1; font-size: 11px; font-family: 'Space Mono', monospace; color: #ff8888; line-height: 1.6; white-space: pre-wrap; }
  .error-close { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 16px; line-height: 1; padding: 0; flex-shrink: 0; }
  /* MR shadow catcher — a subtle disc under the model in MR */
  /* (handled via Three.js object, no CSS needed) */

  /* ─── Gallery overlay ───────────────────────────────────────────────────────── */
  #model-gallery {
    display: none;
    position: fixed; inset: 0; z-index: 110;
    background: rgba(8,8,10,.92);
    backdrop-filter: blur(8px);
    flex-direction: column;
  }
  #model-gallery.open { display: flex; }

  .gallery-topbar {
    display: flex; align-items: center; gap: 16px;
    padding: 14px 24px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
  }
  .gallery-topbar-title {
    font-size: 10px; font-weight: 700; text-transform: uppercase;
    letter-spacing: .15em; color: var(--muted); white-space: nowrap;
  }
  .gallery-search-wrap {
    flex: 1; position: relative; max-width: 480px;
  }
  .gallery-search {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 9px 14px 9px 36px;
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    outline: none;
    transition: border-color .15s;
  }
  .gallery-search:focus { border-color: var(--accent); }
  .gallery-search::placeholder { color: var(--muted); }
  .gallery-search-icon {
    position: absolute; left: 13px; top: 50%; transform: translateY(-50%);
    color: var(--muted); font-size: 14px; pointer-events: none;
  }
  .gallery-status {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); white-space: nowrap; flex-shrink: 0;
  }

  .gallery-body {
    flex: 1; display: flex; overflow: hidden;
  }

  .gallery-sidebar {
    width: 180px; flex-shrink: 0;
    background: var(--panel);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    padding: 16px 14px;
    display: flex; flex-direction: column; gap: 20px;
  }
  .gallery-sidebar::-webkit-scrollbar { width: 3px; }
  .gallery-sidebar::-webkit-scrollbar-track { background: transparent; }
  .gallery-sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .gallery-filter-title {
    font-size: 9px; font-weight: 700; text-transform: uppercase;
    letter-spacing: .15em; color: var(--muted); margin-bottom: 8px;
  }
  .gallery-filter-item {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 0; cursor: pointer;
  }
  .gallery-filter-item input[type=checkbox] {
    accent-color: var(--accent); width: 13px; height: 13px; cursor: pointer; flex-shrink: 0;
  }
  .gallery-filter-label {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--text); white-space: nowrap; overflow: hidden;
    text-overflow: ellipsis; flex: 1;
  }
  .gallery-filter-count {
    font-family: 'Space Mono', monospace; font-size: 9px; color: var(--muted); flex-shrink: 0;
  }

  .gallery-sort-item {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 0; cursor: pointer;
  }
  .gallery-sort-item input[type=radio] {
    accent-color: var(--accent); width: 13px; height: 13px; cursor: pointer; flex-shrink: 0;
  }
  .gallery-sort-label {
    font-family: 'Space Mono', monospace; font-size: 10px; color: var(--text);
  }

  .gallery-main {
    flex: 1; overflow-y: auto; padding: 20px 24px;
    display: flex; flex-direction: column; gap: 20px;
  }
  .gallery-main::-webkit-scrollbar { width: 4px; }
  .gallery-main::-webkit-scrollbar-track { background: transparent; }
  .gallery-main::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 12px;
  }

  .gallery-card {
    width: 100%; min-width: 0; height: 220px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    display: flex; flex-direction: column;
    cursor: pointer; overflow: hidden;
    transition: border-color .15s, box-shadow .15s, transform .15s;
    position: relative;
  }
  .gallery-card:hover {
    border-color: var(--accent);
    box-shadow: 0 4px 20px rgba(255,204,0,.12);
    transform: translateY(-2px);
  }
  .gallery-card:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(255,204,0,.3);
  }

  .gallery-card-thumb-wrap {
    width: 100%; height: 140px; flex-shrink: 0;
    background: var(--bg);
    display: flex; align-items: center; justify-content: center;
    overflow: hidden;
  }
  .gallery-card-thumb {
    width: 100%; height: 100%; object-fit: contain;
    opacity: 0; transition: opacity .2s;
  }
  .gallery-card-thumb.loaded { opacity: 1; }

  /* Brick placeholder — shown while thumb is loading or on error */
  .gallery-card-placeholder {
    width: 44px; height: 32px;
    background: var(--border); border-radius: 2px; position: relative;
    flex-shrink: 0;
  }
  .gallery-card-placeholder::before,
  .gallery-card-placeholder::after {
    content: ''; position: absolute; top: -11px;
    width: 13px; height: 13px; background: var(--border); border-radius: 50%;
  }
  .gallery-card-placeholder::before { left: 6px; }
  .gallery-card-placeholder::after  { right: 6px; }

  .gallery-card-info {
    flex: 1; padding: 6px 8px 8px;
    display: flex; flex-direction: column; gap: 2px; overflow: hidden;
  }
  .gallery-card-name {
    font-family: 'Space Mono', monospace; font-size: 10px; font-weight: 700;
    color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    line-height: 1.3;
  }
  .gallery-card-file {
    font-family: 'Space Mono', monospace; font-size: 9px; color: var(--muted);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .gallery-card-cats,
  .gallery-card-kwd {
    font-family: 'Space Mono', monospace; font-size: 9px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    line-height: 1.3;
  }
  .gallery-card-cats { color: var(--muted); }
  .gallery-card-kwd  { color: #4a8a6a; }   /* muted green — visually distinct from categories */
  .gallery-card-field-label {
    color: var(--muted); opacity: .6; margin-right: 2px;
  }

  .gallery-load-more-wrap {
    display: flex; justify-content: center; padding-bottom: 8px;
  }
  .gallery-load-more {
    font-family: 'Space Mono', monospace; font-size: 11px;
    padding: 10px 32px; border-radius: 4px;
    border: 1px solid var(--border); background: transparent;
    color: var(--text); cursor: pointer; text-transform: uppercase; letter-spacing: .08em;
    transition: all .15s;
  }
  .gallery-load-more:hover { border-color: var(--accent); color: var(--accent); }

  .gallery-empty {
    grid-column: 1/-1; text-align: center; padding: 48px 20px;
    font-family: 'Space Mono', monospace; font-size: 12px; color: var(--muted); line-height: 2;
  }

  /* ─── Scene model list ───────────────────────────────────────────────────── */
  .model-list-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 0; gap: 8px; border-bottom: 1px solid var(--border);
  }
  .model-list-item:last-child { border-bottom: none; }
  .model-list-name {
    font-family: 'Space Mono', monospace; font-size: 10px; color: var(--text);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .model-list-remove {
    background: none; border: none; color: var(--muted); cursor: pointer;
    font-size: 14px; line-height: 1; padding: 0 2px; flex-shrink: 0;
    transition: color .15s;
  }
  .model-list-remove:hover { color: #ff5555; }
  .model-list-empty {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); font-style: italic;
  }
  .model-list-count {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); margin-bottom: 8px;
  }
  .model-list-item.selected .model-list-name { color: var(--accent); }
  .model-list-item.selected { border-color: rgba(255,204,0,.25); }
  /* Show move cursor when hovering canvas in drag-ready state */
  #canvas-container.drag-ready  { cursor: grab; }
  #canvas-container.drag-active { cursor: grabbing; }

  /* ─── XR buttons (VR + MR) injected by JS ───────────────────────────────── */
  .btn.xr-btn, .btn.xr-btn-mr {
    position: static !important;
    width: auto !important; bottom: auto !important;
    left: auto !important;  right: auto !important;
  }
  .btn.xr-btn    { border-color: var(--border); color: var(--text); }
  .btn.xr-btn-mr { border-color: var(--accent-mr); color: var(--accent-mr); }
  .btn.xr-btn:hover    { border-color: var(--accent); color: var(--accent); background: var(--border); }
  .btn.xr-btn-mr:hover { border-color: var(--accent-mr); color: #000; background: var(--accent-mr); }
  .btn.xr-btn:disabled, .btn.xr-btn-mr:disabled { border-color: var(--border); color: var(--muted); cursor: not-allowed; }

</style>
</head>
<body>

<header>
  <div class="logo">
    <div class="logo-brick"></div>
    <h1>LDraw <span>Viewer</span> <span style="font-size:11px;opacity:.4;color:var(--text)">v5</span></h1>
  </div>
  <div class="controls">
    <button class="btn" id="btn-demo">Load Demo</button>
    <button class="btn" id="btn-browse">Browse Models</button>
    <button class="btn" id="btn-reset-view">Reset View</button>
    <input type="file" id="file-input" accept=".ldr,.mpd,.dat">
    <!-- VR and MR buttons are injected here by JS after checking support -->
  </div>
</header>

<div class="workspace">
  <div id="canvas-container">
    <div id="drop-zone">
      <div class="drop-icon"><div class="drop-zone-brick"></div></div>
      <div class="drop-text">
        <h2>Drop LDraw File</h2>
        <p>.ldr &nbsp;·&nbsp; .mpd &nbsp;·&nbsp; .dat</p>
        <p style="margin-top:10px;font-size:10px;opacity:.6">Packed .mpd files work best<br>sub-parts are self-contained</p>
      </div>
    </div>
    <div id="loading-overlay">
      <div class="spinner"></div>
      <div class="loading-text" id="loading-msg">Loading…</div>
      <div class="loading-sub" id="loading-sub"></div>
    </div>
    <div class="error-banner" id="error-banner">
      <div class="error-banner-text" id="error-text"></div>
      <button class="error-close" id="btn-error-close">✕</button>
    </div>
    <div id="mode-badge"></div>
    <div id="status">No model loaded</div>
  </div>

  <div class="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">Scene</div>
      <div class="model-list-count" id="scene-count">No models loaded</div>
      <div id="scene-model-list"><span class="model-list-empty">—</span></div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Display</div>
      <div class="toggle-row">
        <span class="toggle-label">Edges</span>
        <div class="toggle on" id="toggle-edges"></div>
      </div>
      <div class="toggle-row">
        <span class="toggle-label">Grid</span>
        <div class="toggle on" id="toggle-grid"></div>
      </div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Load</div>
      <input type="text" class="url-input" id="url-input" placeholder="https://…/model.mpd">
      <button class="btn" id="btn-load-url" style="width:100%;margin-top:2px">Load from URL</button>
      <div style="border-top:1px solid var(--border);margin:10px 0"></div>
      <button class="btn primary" id="btn-open-file" style="width:100%">Open File…</button>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Browser Controls</div>
      <div class="hint">
        Left drag — Orbit<br>
        Right drag — Pan camera<br>
        Scroll — Zoom<br>
        Double-click — Focus<br>
        <br>
        <b>Move a model:</b><br>
        Right-drag on model<br>
        Click model, then<br>
        arrow keys to nudge
      </div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">VR / MR Controls</div>
      <div class="hint">
        Aim at a model, then:<br>
        <b>Grip</b> — grab &amp; move<br>
        <b>Trigger</b> — rotate<br>
        <b>Thumbstick ↑↓</b> — scale<br>
        <b>B / Y</b> — remove model<br>
        <br>
        White ray = ready<br>
        Red ray = active<br>
        <br>
        <b>MR mode:</b> models float<br>
        in your real room.
      </div>
    </div>
    <div class="sidebar-section" style="flex:1">
      <div class="sidebar-title">File Format Tips</div>
      <div class="hint">
        Packed .mpd files load<br>fully self-contained.<br><br>
        Plain .ldr files need<br>sub-parts fetched from<br>the LDraw CDN — requires<br>internet access.
      </div>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
    "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.4/src/index.js",
    "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.8.2/esm/browser.js"
  }
}
</script>

<!-- Fuse.js for fuzzy search -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/7.0.0/fuse.min.js"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }            from 'three/addons/controls/OrbitControls.js';
import { LDrawLoader }              from 'three/addons/loaders/LDrawLoader.js';
import { RoomEnvironment }          from 'three/addons/environments/RoomEnvironment.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';
import { unzipSync }                from 'fflate';

// Patch Three.js prototypes once — every Mesh and BufferGeometry in the scene
// automatically gets BVH-accelerated raycasting after this point.
THREE.BufferGeometry.prototype.computeBoundsTree  = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree  = disposeBoundsTree;
THREE.Mesh.prototype.raycast                      = acceleratedRaycast;


// ─── §1  Config ───────────────────────────────────────────────────────────────

const BASE_REPO   = 'anteloc/ldraw-lib';
const REPO_BRANCH = 'master';
const PARTS_CDN    = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/ldraw/`;
const DEMO_MODEL   = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models-packed/8419-1.mpd`;
const MODELS_INDEX = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models-index.jsonl`;
const RAW_BASE     = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models-packed/`;

// XR scene hierarchy constants
// LDU → metres: 1 LDU = 0.4 mm = 0.0004 m, ×2.5 = hand-held / table-top scale
const LDU_TO_METERS = 0.0004 * 2.5;
const MAX_MODELS    = 5;
const MODEL_SPACING = 0.35;   // metres between model pivots in XR
const MODEL_PIVOT_Y = 0.9;    // metres above floor
const MODEL_PIVOT_Z = -0.6;   // metres in front of user

// XR controller / laser constants
const LASER_LENGTH          = 5;      // metres
const LASER_RADIUS          = 0.003;  // metres — visible thickness in VR
const COLOR_IDLE            = 0xffffff;
const COLOR_HIT             = 0x44ff44;  // green — laser touching a model, interaction ready
const COLOR_GRABBED         = 0xff2222;
const SCALE_SPEED           = 0.02;   // scale change per frame at full thumbstick deflection
const PUSH_SPEED            = 0.04;   // metres per frame at full thumbstick deflection
const TRACKBALL_SPEED       = 15.0;   // radians of rotation per metre of hand travel
// Raycasting throttle: when no gesture is active, only raycast every N frames.
// At 72fps, N=3 gives ~24 laser updates/sec — imperceptible for idle aiming.
// Active gestures always raycast every frame for precision.
const RAYCAST_IDLE_INTERVAL = 3;

// Browser interaction constants
const NUDGE_STEP = 100;   // LDU — about 4 cm at 1:1 scale
const GRID_HALF  = 2000;  // LDU — half the grid width; models are clamped to ±this

// Model browser / gallery
const GALLERY_PAGE_SIZE = 48;
const THUMB_BASE        = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/thumbnails/`;

// Scene background colour — saved here so onXRSessionEnd can restore it
const BROWSER_BG = new THREE.Color(0x0e0e10);


// ─── §2  Renderer + Scene ─────────────────────────────────────────────────────

const container = document.getElementById('canvas-container');

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;    // PCFSoft is overkill; PCF is a good balance
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = BROWSER_BG;

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;


// ─── §3  Scene objects — lights, grid, ground, MR shadow disc ────────────────

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
dirLight.position.set(500, 1000, 500);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(1024, 1024);
Object.assign(dirLight.shadow.camera, { near: 1, far: 10000, left: -2000, right: 2000, top: 2000, bottom: -2000 });
scene.add(dirLight);

// Grid & shadow ground — browser / VR only, hidden in MR
const gridHelper = new THREE.GridHelper(4000, 50, 0x333344, 0x222230);
scene.add(gridHelper);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(10000, 10000),
  new THREE.ShadowMaterial({ opacity: 0.2 })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// MR shadow disc — subtle circle anchoring the model to the real-world surface.
// Replaces the grid in MR mode where an opaque floor plane is inappropriate.
const mrShadowDisc = new THREE.Mesh(
  new THREE.CircleGeometry(0.18, 64),
  new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25, depthWrite: false })
);
mrShadowDisc.rotation.x = -Math.PI / 2;
mrShadowDisc.visible = false; // shown only in MR
scene.add(mrShadowDisc);


// ─── §4  Camera + OrbitControls ───────────────────────────────────────────────

const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 50000);
camera.position.set(0, 400, 1200);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

function resize() {
  const w = container.clientWidth, h = container.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
resize();
window.addEventListener('resize', resize);


// ─── §5  Model registry ───────────────────────────────────────────────────────
//
// Each loaded model lives in a ModelEntry:
//
//   scene
//     ├── (browser) entry.mesh   ← normal scale, LDU units
//     └── entry.pivot            ← world position of model in XR
//           ├── entry.root       ← uniform scale (LDU→metres) + rotation
//           │     └── (XR) entry.mesh
//           └── entry.orb        ← trackball orb, shown during rotate gesture
//                 ├── invisible sphere  (intercepts laser raycast)
//                 └── three ring lines  (red=X, green=Y, blue=Z)

const models = [];   // all currently loaded models, in load order
const _meshList = []; // cached models.map(e => e.mesh) — updated on load/remove

let edgesVisible  = true;
let selectedEntry = null;   // model currently selected for keyboard nudge

// ── Trackball orb ─────────────────────────────────────────────────────────────
//
// Built once per entry; sized and shown in startRotate, hidden in endInteraction.
// The invisible sphere intercepts the laser so rotation works on the orb surface.
// The three torus rings (RGB = XYZ) give the classic CAD trackball visual.

function makeOrb(entry) {
  const orb = new THREE.Group();
  orb.visible = false;

  // Invisible sphere — raycasted as if solid, but never rendered.
  // Radius is set in startRotate once we know the model's bounding sphere.
  const sphereGeo = new THREE.SphereGeometry(1, 32, 24);
  const sphereMat = new THREE.MeshBasicMaterial({
    transparent: true, opacity: 0, depthWrite: false, side: THREE.FrontSide,
  });
  const sphere = new THREE.Mesh(sphereGeo, sphereMat);
  sphere.userData.orbEntry = entry;   // laser hit → look up entry
  orb.add(sphere);

  // Three ring lines — TorusGeometry, one per axis
  const torusSeg = 128;   // smooth circle
  const tubeR    = 0.012; // thin tube in metres (scaled with orb)
  const rings = [
    { color: 0xff2222, rx: 0,           ry: 0           },   // X-axis ring (lies in YZ plane)
    { color: 0x22ff22, rx: Math.PI / 2, ry: 0           },   // Y-axis ring (lies in XZ plane)
    { color: 0x2266ff, rx: 0,           ry: Math.PI / 2 },   // Z-axis ring (lies in XY plane)
  ];

  rings.forEach(({ color, rx, ry }) => {
    const geo  = new THREE.TorusGeometry(1, tubeR, 12, torusSeg);
    const mat  = new THREE.MeshBasicMaterial({ color, depthTest: false, transparent: true, opacity: 0.85 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = rx;
    mesh.rotation.y = ry;
    orb.add(mesh);
  });

  return { orb, sphere };
}

function createEntry(mesh, name) {
  // Place new XR pivot to the right of all existing ones
  const pivotX = models.reduce((maxX, e) => Math.max(maxX, e.pivot.position.x), 0)
    + (models.length > 0 ? MODEL_SPACING : 0);

  const pivot = new THREE.Group();
  pivot.position.set(pivotX, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
  scene.add(pivot);

  const root = new THREE.Group();
  root.scale.setScalar(LDU_TO_METERS);
  pivot.add(root);

  // Orb is parented to root — rigidly attached to the model, rotates with it.
  // Sized in onXRSessionStart once the mesh is re-centred into root-local space.
  const entry = { mesh, pivot, root, name, orb: null, orbSphere: null };
  const { orb, sphere } = makeOrb(entry);
  entry.orb       = orb;
  entry.orbSphere = sphere;
  root.add(orb);

  return entry;
}

function fitCamera() {
  if (models.length === 0) {
    camera.position.set(0, 400, 1200);
    controls.target.set(0, 0, 0);
    controls.update();
    return;
  }
  const box = new THREE.Box3();
  for (const entry of models) box.expandByObject(entry.mesh);
  const size   = box.getSize(new THREE.Vector3());
  const centre = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const dist   = (maxDim / (2 * Math.tan(camera.fov * Math.PI / 360))) * 1.6;
  controls.target.copy(centre);
  camera.position.set(centre.x + dist * 0.3, centre.y + dist * 0.4, centre.z + dist);
  controls.update();
  gridHelper.position.y = box.min.y;
  ground.position.y     = box.min.y;
}

function renderModelList() {
  sceneCountEl.textContent = models.length === 0
    ? 'No models loaded'
    : `${models.length} / ${MAX_MODELS} model${models.length > 1 ? 's' : ''}`;

  sceneModelListEl.innerHTML = models.length === 0
    ? '<span class="model-list-empty">—</span>'
    : models.map((entry, i) =>
        `<div class="model-list-item${entry === selectedEntry ? ' selected' : ''}">` +
          `<span class="model-list-name" title="${escHtml(entry.name)}">${escHtml(entry.name)}</span>` +
          `<button class="model-list-remove" data-idx="${i}" title="Remove from scene">✕</button>` +
        `</div>`
      ).join('');
}

function disposeMesh(mesh) {
  mesh.traverse(o => {
    if (o.geometry) { o.geometry.disposeBoundsTree?.(); o.geometry.dispose(); }
    if (o.material) (Array.isArray(o.material) ? o.material : [o.material]).forEach(m => m.dispose());
  });
}

function removeEntry(entry) {
  // Release any XR slot targeting this entry
  for (const slot of slots) {
    if (slot.grab.entry === entry || slot.rotate.entry === entry) endInteraction(slot);
  }
  if (selectedEntry === entry) selectedEntry = null;

  const { mesh, pivot, root, orb } = entry;
  root.remove(mesh);
  scene.remove(mesh);
  scene.remove(pivot);
  disposeMesh(mesh);
  if (orb) orb.traverse(o => {
    if (o.geometry) o.geometry.dispose();
    if (o.material) o.material.dispose();
  });

  models.splice(models.indexOf(entry), 1);
  _meshList.splice(_meshList.indexOf(entry.mesh), 1);
  renderModelList();

  if (models.length === 0) {
    dropZone.style.display = '';
    setStatus('No model loaded');
  } else {
    fitCamera();
  }
}

function clearAllModels() {
  for (const entry of models.slice()) removeEntry(entry); // slice — don't mutate while iterating
}


// ─── §6  Model loading ────────────────────────────────────────────────────────
//
// makeLDrawLoader — constructs and primes a loader in one await.
//   preloadMaterials failure is swallowed; the loader still resolves
//   colours correctly for packed .mpd files without it.
//
// loadModelFromURL  — resolves with the model group (throws on error).
// loadModelFromText — synchronous: parse() returns the group directly.
//
// Both call onModelLoaded on success; errors are surfaced via showError.

function onProgress(xhr) {
  if (xhr.total) loadingSub.textContent = 'Downloading… ' + Math.round(xhr.loaded / xhr.total * 100) + '%';
}

async function makeLDrawLoader() {
  const loader = new LDrawLoader();
  loader.setPartsLibraryPath(PARTS_CDN);
  await loader.preloadMaterials(PARTS_CDN + 'LDConfig.ldr').catch(() => {});
  return loader;
}

async function loadModelFromURL(url, name, errorMsg) {
  try {
    if (url.endsWith('.zip')) {
      // ── Zipped model: fetch as binary, decompress in-memory, parse as text ──
      const resp   = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const buffer = await resp.arrayBuffer();
      const files  = unzipSync(new Uint8Array(buffer));
      const entries = Object.keys(files);
      if (entries.length === 0) throw new Error('Zip archive is empty');
      // Take the first file — archives contain exactly one .mpd/.ldr
      const text = new TextDecoder().decode(files[entries[0]]);
      const displayName = name.replace(/\.zip$/i, '');
      onModelLoaded(await _parseWithLoader(text), displayName);
    } else {
      const loader = await makeLDrawLoader();
      const model  = await loader.loadAsync(url, onProgress);
      onModelLoaded(model, name);
    }
  } catch (err) {
    showError(errorMsg + '\n\n' + err);
  }
}

// Shared helper: build a loader and parse model text via a temporary Blob URL.
// LDrawLoader.parse() expects callbacks and is not safely callable without them;
// wrapping the text in a Blob and using loadAsync drives the full lifecycle correctly.
// The object URL is revoked immediately after the load resolves to avoid memory leaks.
async function _parseWithLoader(text) {
  const loader = await makeLDrawLoader();
  const blob   = new Blob([text], { type: 'text/plain' });
  const url    = URL.createObjectURL(blob);
  try {
    return await loader.loadAsync(url, onProgress);
  } finally {
    URL.revokeObjectURL(url);
  }
}

async function loadModelFromText(text, name) {
  try {
    onModelLoaded(await _parseWithLoader(text), name);
  } catch (err) {
    console.error(err);
    showError('Parse error: ' + (err?.message || String(err)) +
      '\n\nPacked .mpd files work best — all sub-parts are bundled inside.');
  }
}

function onModelLoaded(model, filename) {
  if (models.length >= MAX_MODELS) {
    showError(`Maximum ${MAX_MODELS} models in scene. Remove one first.`);
    return;
  }

  errorBanner.classList.remove('visible');
  model.rotation.x = Math.PI; // LDraw Y-down → Y-up
  model.traverse(o => {
    if (o.isMesh) {
      o.castShadow = true;
      o.receiveShadow = true;
      o.geometry.computeBoundsTree();   // BVH — O(log n) raycasts
    } else if (o.isLineSegments) {
      o.raycast = () => {};             // edges are visual only — never raycasted
    }
  });

  scene.add(model);
  const entry = createEntry(model, filename);
  models.push(entry);
  _meshList.push(model);

  // In browser mode, separate models along X so they don't stack on top of each other.
  // Compute the right edge of all existing models and place the new one just past it.
  if (models.length > 1) {
    const existingBox = new THREE.Box3();
    for (const e of models.slice(0, -1)) existingBox.expandByObject(e.mesh);
    const newBox  = new THREE.Box3().setFromObject(model);
    const newSize = newBox.getSize(new THREE.Vector3());
    const gap     = newSize.x * 0.2;   // 20% of own width as breathing room
    model.position.x = existingBox.max.x + gap + newSize.x / 2 - newBox.getCenter(new THREE.Vector3()).x;
  }

  if (models.length === 1) dropZone.style.display = 'none';
  fitCamera();
  renderModelList();
  hideLoading();
  setStatus(`Loaded: ${filename} (${models.length}/${MAX_MODELS} in scene)`);
}

function loadFile(file) {
  if (!file) return;
  showLoading('Reading file…', file.name);
  const reader = new FileReader();
  reader.onload = e => {
    showLoading('Parsing model…', 'Sub-parts resolved from LDraw CDN — needs internet');
    loadModelFromText(e.target.result, file.name);
  };
  reader.onerror = () => showError('Could not read file.');
  reader.readAsText(file);
}

function loadFromURL() {
  const url = document.getElementById('url-input').value.trim();
  if (!url) return;
  showLoading('Fetching…', url);
  loadModelFromURL(url, url.split('/').pop(), 'Could not load URL — CORS may be blocking it.\nTry downloading and opening locally.');
}


// ─── §7  Browser interaction — drag, select, focus, nudge ────────────────────
//
// Right-click drag on a model → move it in X/Z on its own ground plane.
// Left-click on a model       → select it (arrow keys nudge it).
// Right-click on empty space  → falls through to OrbitControls pan.
// Quest 3 browser: click-and-hold (150 ms) triggers drag same as right-drag.

// Reusable temporaries — never allocated per event
const _browserRay = new THREE.Raycaster();
const _dragPlane  = new THREE.Plane();
const _dragOffset = new THREE.Vector3();
const _planeHit   = new THREE.Vector3();
const _ndcVec     = new THREE.Vector2();

let _dragEntry      = null;   // entry currently being dragged
let _dragActive     = false;
let _holdTimer      = null;   // for Quest-style click-and-hold
let _pointerDownPos = null;   // { x, y } at pointerdown

// Sets _browserRay from a DOM client-space coordinate.
// Centralises the NDC conversion used by raycast, drag-start, and drag-move.
function setRayFromClient(clientX, clientY) {
  const rect = renderer.domElement.getBoundingClientRect();
  _ndcVec.set(
    ((clientX - rect.left)  / rect.width)  * 2 - 1,
    -((clientY - rect.top) / rect.height) * 2 + 1
  );
  _browserRay.setFromCamera(_ndcVec, camera);
}

function browserRaycast(clientX, clientY) {
  setRayFromClient(clientX, clientY);
  const hits = _browserRay.intersectObjects(_meshList, true);
  return hits.length > 0 ? hits[0] : null;
}

function hitToEntry(hit) {
  // Each entry's mesh is the root of the loaded model — if the hit object
  // lives anywhere inside it, getObjectById will find it in one call.
  return models.find(e => e.mesh.getObjectById(hit.object.id)) ?? null;
}

function selectEntry(entry) {
  selectedEntry = entry;
  renderModelList();
}

function startDrag(entry, clientX, clientY) {
  _dragEntry  = entry;
  _dragActive = true;
  controls.enabled = false;
  container.classList.add('drag-active');
  container.classList.remove('drag-ready');

  // Build a horizontal plane at the model's current Y
  _dragPlane.set(new THREE.Vector3(0, 1, 0), -entry.mesh.position.y);

  // Record offset from plane hit to model origin so it doesn't snap to cursor
  setRayFromClient(clientX, clientY);
  _browserRay.ray.intersectPlane(_dragPlane, _planeHit);
  _dragOffset.set(entry.mesh.position.x - _planeHit.x, 0, entry.mesh.position.z - _planeHit.z);
}

// Clamp a mesh's X/Z position to the grid boundary so it can't be dragged
// or nudged off the visible floor into unreachable space.
function clampToFloor(mesh) {
  mesh.position.x = THREE.MathUtils.clamp(mesh.position.x, -GRID_HALF, GRID_HALF);
  mesh.position.z = THREE.MathUtils.clamp(mesh.position.z, -GRID_HALF, GRID_HALF);
}

function moveDrag(clientX, clientY) {
  if (!_dragActive || !_dragEntry) return;
  setRayFromClient(clientX, clientY);
  if (_browserRay.ray.intersectPlane(_dragPlane, _planeHit)) {
    _dragEntry.mesh.position.x = _planeHit.x + _dragOffset.x;
    _dragEntry.mesh.position.z = _planeHit.z + _dragOffset.z;
    clampToFloor(_dragEntry.mesh);
  }
}

function endDrag() {
  if (_holdTimer) { clearTimeout(_holdTimer); _holdTimer = null; }
  if (!_dragActive) return;
  _dragActive = false;
  _dragEntry  = null;
  controls.enabled = true;
  container.classList.remove('drag-active');
}

function resetView() {
  if (renderer.xr.isPresenting) {
    let x = 0;
    for (const entry of models) {
      entry.root.scale.setScalar(LDU_TO_METERS);
      entry.root.rotation.set(0, 0, 0);
      entry.pivot.position.set(x, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
      x += MODEL_SPACING;
    }
    mrShadowDisc.position.set(0, 0.02, MODEL_PIVOT_Z);
    mrShadowDisc.scale.setScalar(1);
  } else {
    fitCamera();
  }
}

function toggleEdges() {
  edgesVisible = !edgesVisible;
  document.getElementById('toggle-edges').classList.toggle('on', edgesVisible);
  for (const entry of models) {
    entry.mesh.traverse(o => { if (o.isLineSegments) o.visible = edgesVisible; });
  }
}

function toggleGrid() {
  const on = !gridHelper.visible;
  gridHelper.visible = on;
  document.getElementById('toggle-grid').classList.toggle('on', on);
}


// ─── §8  XR controllers — lasers, slots, per-frame interaction ────────────────
//
// Three.js exposes two separate tracked spaces per physical controller:
//   getController(i)     → pointer / target-ray space  (laser origin)
//   getControllerGrip(i) → grip space                  (where the hand holds it)
//
// The controller model from XRControllerModelFactory must be attached to the
// grip space; the laser must be attached to the pointer space.
// Both are added to the scene and their poses are updated automatically by the
// XR runtime each frame — no manual position/quaternion sync needed.
//
// Each physical controller has its own independent interaction slot so both
// hands can interact with different models simultaneously.
//
// slot.type      — null | 'grab' | 'rotate'
// slot.grab      — grab state, valid while type === 'grab'
// slot.rotate    — rotate state, valid while type === 'rotate'
//
// Cross-controller rule: two grabs on the *same* model are denied — they would
// fight each other. Any other combination is allowed.

const controllerModelFactory = new XRControllerModelFactory();

// Reusable temporaries — never allocated per-frame
const _ctrlWorldPos  = new THREE.Vector3();
const _ctrlWorldQuat = new THREE.Quaternion();
const _ctrlWorldQInv = new THREE.Quaternion();
const _raycaster     = new THREE.Raycaster();
_raycaster.firstHitOnly = true;   // BVH short-circuits after first hit — much faster
const _rayOrigin     = new THREE.Vector3();
const _rayDir        = new THREE.Vector3();
const _pushVec       = new THREE.Vector3();
const _currentArm    = new THREE.Vector3();   // reused as hand-delta in applyRotate
const _rotQuat       = new THREE.Quaternion();

let _frameCount = 0;

// ── Laser — cylinder beam + tip ring ──────────────────────────────────────────
//
// A CylinderGeometry is used instead of Line because WebGL does not support
// line widths > 1px on most drivers, making Line invisible at VR scale.
// The cylinder is oriented along –Z (the pointer forward direction).

function makeLaser() {
  const group = new THREE.Group();

  // Beam — thin cylinder from origin to LASER_LENGTH along –Z
  const beamMat = new THREE.MeshBasicMaterial({ color: COLOR_IDLE, transparent: true, opacity: 0.6 });
  const beam = new THREE.Mesh(new THREE.CylinderGeometry(LASER_RADIUS, LASER_RADIUS, LASER_LENGTH, 8), beamMat);
  // CylinderGeometry stands along Y; rotate and translate so it lies along –Z
  beam.rotation.x = Math.PI / 2;
  beam.position.z = -LASER_LENGTH / 2;
  group.add(beam);

  // Tip ring — faces along the ray axis (perpendicular to –Z)
  const ringMat = new THREE.MeshBasicMaterial({ color: COLOR_IDLE, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
  const ring = new THREE.Mesh(new THREE.RingGeometry(0.006, 0.012, 32), ringMat);
  ring.position.z = -LASER_LENGTH;
  group.add(ring);

  return group;
}

function setLaserColor(pointer, color) {
  const laser = pointer.children[0];
  laser.children[0].material.color.setHex(color);  // beam
  laser.children[1].material.color.setHex(color);  // ring
}

// Called every frame for each controller. Casts a ray against all loaded
// models, scales the beam and repositions the tip ring to the hit point
// (or restores full length on a miss). Returns { hitPoint, hitEntry }.
function updateLaser(pointer) {
  const beam = pointer.children[0].children[0];
  const ring = pointer.children[0].children[1];
  const resetBeam = () => { beam.scale.z = 1; ring.position.z = -LASER_LENGTH; };

  if (models.length === 0) return resetBeam() || { hitPoint: null, hitEntry: null };

  pointer.getWorldPosition(_rayOrigin);
  _rayDir.set(0, 0, -1).transformDirection(pointer.matrixWorld);
  _raycaster.set(_rayOrigin, _rayDir);
  // Snapshot ray direction for push/pull — used by thumbstick Y in updateXRControls
  if (!pointer.userData.rayDir) pointer.userData.rayDir = new THREE.Vector3();
  pointer.userData.rayDir.copy(_rayDir);

  // Test all loaded models; prefer orb sphere when rotating (orb visible),
  // otherwise test the mesh directly. Pick nearest hit across all entries.
  let nearestDist  = Infinity;
  let nearestPoint = null;
  let nearestEntry = null;

  for (const entry of models) {
    const target = (entry.orb?.visible) ? entry.orbSphere : entry.mesh;
    const hits   = _raycaster.intersectObject(target, /* recursive */ true);
    if (hits.length > 0 && hits[0].distance < nearestDist) {
      nearestDist  = hits[0].distance;
      nearestPoint = hits[0].point;
      nearestEntry = entry;
    }
  }

  if (nearestEntry === null) return resetBeam() || { hitPoint: null, hitEntry: null };

  beam.scale.z = nearestDist / LASER_LENGTH;
  ring.position.z = -nearestDist;
  return { hitPoint: nearestPoint, hitEntry: nearestEntry };
}

// ── Interaction slots ──────────────────────────────────────────────────────────

function makeSlot() {
  return {
    type:    null,
    pointer: null,
    grab: {
      entry:      null,
      offsetPos:  new THREE.Vector3(),
      offsetQuat: new THREE.Quaternion(),
    },
    rotate: {
      entry:   null,
      prevPos: new THREE.Vector3(),   // controller world position last frame
    },
  };
}

const slots = [makeSlot(), makeSlot()];

function otherSlot(slot) {
  return slots[1 - slots.indexOf(slot)];
}

function startGrab(slot, pointer, hitPoint, hitEntry) {
  // Deny if the other hand is already grabbing the same model
  const other = otherSlot(slot);
  if (other.type === 'grab' && other.grab.entry === hitEntry) return;

  const { pivot, root } = hitEntry;
  pointer.getWorldPosition(_ctrlWorldPos);
  pointer.getWorldQuaternion(_ctrlWorldQuat);
  _ctrlWorldQInv.copy(_ctrlWorldQuat).invert();

  slot.grab.entry = hitEntry;
  slot.grab.offsetPos
    .copy(pivot.position)
    .sub(_ctrlWorldPos)
    .applyQuaternion(_ctrlWorldQInv);
  slot.grab.offsetQuat
    .multiplyQuaternions(_ctrlWorldQInv, root.getWorldQuaternion(new THREE.Quaternion()));

  slot.type    = 'grab';
  slot.pointer = pointer;
  setLaserColor(pointer, COLOR_GRABBED);
}

function startRotate(slot, pointer, hitPoint, hitEntry) {
  pointer.getWorldPosition(slot.rotate.prevPos);
  slot.rotate.entry = hitEntry;
  if (hitEntry.orb) hitEntry.orb.visible = true;
  slot.type    = 'rotate';
  slot.pointer = pointer;
  setLaserColor(pointer, COLOR_GRABBED);
}

function endInteraction(slot) {
  if (!slot.type) return;
  if (slot.pointer) setLaserColor(slot.pointer, COLOR_IDLE);
  if (slot.type === 'rotate' && slot.rotate.entry?.orb) slot.rotate.entry.orb.visible = false;
  slot.type         = null;
  slot.pointer      = null;
  slot.grab.entry   = null;
  slot.rotate.entry = null;
}

function applyGrab(slot) {
  const { pivot, root } = slot.grab.entry;
  const ctrl = slot.pointer;
  ctrl.getWorldPosition(_ctrlWorldPos);
  ctrl.getWorldQuaternion(_ctrlWorldQuat);

  pivot.position
    .copy(slot.grab.offsetPos)
    .applyQuaternion(_ctrlWorldQuat)
    .add(_ctrlWorldPos);

  root.quaternion.multiplyQuaternions(_ctrlWorldQuat, slot.grab.offsetQuat);

  mrShadowDisc.position.x = pivot.position.x;
  mrShadowDisc.position.z = pivot.position.z;
}

function applyRotate(slot) {
  const { entry, prevPos } = slot.rotate;
  const { pivot, root }    = entry;

  slot.pointer.getWorldPosition(_ctrlWorldPos);

  // Delta of controller movement since last frame
  _currentArm.subVectors(_ctrlWorldPos, prevPos);   // reusing _currentArm as delta
  if (_currentArm.lengthSq() < 1e-10) {
    prevPos.copy(_ctrlWorldPos);
    return;
  }

  // Trackball mapping (Three.js world: +X right, +Y up, +Z toward user):
  //   hand moves right (+X) → rotate around −Y (model's right face swings away)
  //   hand moves up    (+Y) → rotate around −X (model's top tips away from user)
  //   hand moves fwd   (+Z) → rotate around +Z (arc / roll)
  const dx = -_currentArm.x * TRACKBALL_SPEED;
  const dy = _currentArm.y * TRACKBALL_SPEED;
  const dz = _currentArm.z * TRACKBALL_SPEED;

  _rotQuat.set(-dy / 2, -dx / 2, dz / 2, 1).normalize();
  root.quaternion.premultiply(_rotQuat);

  prevPos.copy(_ctrlWorldPos);
}

// Called every frame while XR is presenting
function updateXRControls() {
  _frameCount++;

  // 1. Update laser visuals — throttled when idle, every frame when active.
  //    Active = at least one slot has an ongoing gesture.
  const anyActive = slots.some(s => s.type !== null);
  const doRaycast = anyActive || (_frameCount % RAYCAST_IDLE_INTERVAL === 0);

  if (doRaycast) {
    for (let i = 0; i < controllers.length; i++) {
      const { pointer } = controllers[i];
      ({ hitPoint: pointer.userData.hitPoint,
         hitEntry: pointer.userData.hitEntry } = updateLaser(pointer));

      // Update idle-state color: green when touching a model, white when not.
      // Skip if this controller is mid-interaction — startGrab/startRotate own
      // the color while active, and endInteraction restores it.
      if (slots[i].type === null) {
        const isHit = !!pointer.userData.hitEntry;
        setLaserColor(pointer, isHit ? COLOR_HIT : COLOR_IDLE);
      }
    }
  }

  // 2. Apply both interaction slots independently
  for (const slot of slots) {
    if (slot.type === 'grab')   applyGrab(slot);
    if (slot.type === 'rotate') applyRotate(slot);
  }

  // 3. Thumbstick scaling — active on any controller whose laser hits a model
  for (const { pointer } of controllers) {
    const entry = pointer.userData.hitEntry;
    if (!entry) continue;

    const source = pointer.userData.xrInputSource;
    if (!source?.gamepad) continue;

    // axes[2] = thumbstick X: positive = right → scale up; negative = left → scale down
    const thumbX = source.gamepad.axes[2] ?? 0;
    if (Math.abs(thumbX) <= 0.1) continue;

    const newScale = THREE.MathUtils.clamp(
      entry.root.scale.x * (1 + thumbX * SCALE_SPEED),
      LDU_TO_METERS * 0.05,
      LDU_TO_METERS * 30
    );
    entry.root.scale.setScalar(newScale);
    mrShadowDisc.scale.setScalar(newScale / LDU_TO_METERS);
  }

  // 4. Thumbstick push/pull — move model along the laser ray when idle and hitting.
  //    up (thumbY < 0) = push away;  down (thumbY > 0) = pull closer.
  //    Only active when the laser is green (slot idle + hitEntry exists).
  for (let i = 0; i < controllers.length; i++) {
    const { pointer } = controllers[i];
    if (slots[i].type !== null) continue;           // skip — mid-interaction

    const entry = pointer.userData.hitEntry;
    if (!entry) continue;                           // skip — laser not on a model

    const source = pointer.userData.xrInputSource;
    if (!source?.gamepad) continue;

    // axes[3] = thumbstick Y: positive = down (pull), negative = up (push)
    const thumbY = source.gamepad.axes[3] ?? 0;
    if (Math.abs(thumbY) <= 0.1) continue;

    // Translate pivot along ray direction — positive thumbY pulls (negate ray = toward user)
    _pushVec.copy(pointer.userData.rayDir).multiplyScalar(-thumbY * PUSH_SPEED);
    entry.pivot.position.add(_pushVec);
  }

  // 5. B/Y button — remove the model the laser is currently hitting.
  //    Rising-edge detection fires exactly once per press.
  for (const { pointer } of controllers) {
    const source     = pointer.userData.xrInputSource;
    const pressed    = source?.gamepad?.buttons[5]?.pressed ?? false;
    const wasPressed = pointer.userData.prevBYPressed ?? false;
    pointer.userData.prevBYPressed = pressed;

    if (pressed && !wasPressed) {
      const entry = pointer.userData.hitEntry;
      if (entry) removeEntry(entry);
    }
  }

  // 6. A/X button — toggle the mini-display; only one controller at a time.
  //    Uses handedness (set on 'connected') to find the other controller,
  //    since connection order does not reliably map to left/right.
  for (let i = 0; i < controllers.length; i++) {
    const { pointer } = controllers[i];
    const source      = pointer.userData.xrInputSource;
    const pressed     = source?.gamepad?.buttons[4]?.pressed ?? false;
    const wasPressed  = pointer.userData.prevAXPressed ?? false;
    pointer.userData.prevAXPressed = pressed;

    if (pressed && !wasPressed && pointer.userData.miniDisplay) {
      const myDisplay = pointer.userData.miniDisplay;

      // Find other controller by opposite handedness
      const otherHand    = pointer.userData.handedness === 'left' ? 'right' : 'left';
      const otherPointer = controllers.find(c => c.pointer.userData.handedness === otherHand)?.pointer;
      const otherDisplay = otherPointer?.userData.miniDisplay;

      if (myDisplay.visible) {
        myDisplay.visible = false;
      } else {
        if (otherDisplay) otherDisplay.visible = false;
        myDisplay.visible = true;
      }
    }
  }
}

// ── Mini-display ───────────────────────────────────────────────────────────────
//
// A rigid virtual screen attached to the controller grip.
// Parented to grip space — rotates 1:1 with hand/wrist movements.
// Toggle with A (right) / X (left) — buttons[4].
// Only one controller shows the display at a time: pressing A/X while the
// other hand's display is visible hides that one first.

// SVG icon definitions — inline data URLs, drawn onto the canvas via drawImage.
// Each is 44×44, coloured via `fill` in the SVG, rendered at ~32×32 on canvas.
function _svgIcon(pathD, fill) {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44">
    <path d="${pathD}" fill="${fill}"/>
  </svg>`;
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
  return img;
}

const ICON_SIZE = 28;   // px on canvas

// Trigger — index finger extended, curling toward a trigger
// (simplified: a pointing hand silhouette)
const _iconTrigger = _svgIcon(
  'M22 4 C18 4 15 7 15 11 L15 24 C15 26 13 28 13 28 L13 36 C13 38 15 40 17 40 L30 40 C32 40 34 38 34 36 L34 26 C34 24 32 22 30 22 L28 22 L28 11 C28 7 25 4 22 4Z M18 22 L18 11 C18 9 20 8 22 8 C24 8 25 9 25 11 L25 22Z',
  '#ffcc00'
);

// Grip — four fingers wrapped, squeeze gesture
const _iconGrip = _svgIcon(
  'M12 16 C12 12 15 10 18 10 C19 10 20 10.5 20 10.5 C20 10.5 21 8 23 8 C25 8 26 9.5 26 10.5 C26 10.5 27 9 29 9 C31 9 32 11 32 13 L32 14 C33 14 34 15 34 17 L34 28 C34 33 30 37 25 37 L22 37 C17 37 12 33 12 28Z M18 14 L18 22 M22 13 L22 22 M26 14 L26 22',
  '#ffcc00'
);

// Stick ←→ — horizontal double-headed arrow
const _iconStickH = _svgIcon(
  'M8 22 L16 14 L16 19 L28 19 L28 14 L36 22 L28 30 L28 25 L16 25 L16 30Z',
  '#44ff44'
);

// Stick ↑↓ — vertical double-headed arrow
const _iconStickV = _svgIcon(
  'M22 6 L30 14 L25 14 L25 30 L30 30 L22 38 L14 30 L19 30 L19 14 L14 14Z',
  '#44ff44'
);

function makeMiniDisplay() {
  const group = new THREE.Group();
  group.visible = false;

  // ── Canvas ────────────────────────────────────────────────────────────────
  const W = 512, H = 256;
  const canvas = document.createElement('canvas');
  canvas.width  = W;
  canvas.height = H;
  const ctx = canvas.getContext('2d');

  const texture = new THREE.CanvasTexture(canvas);

  function drawPanel(icons) {
    const r = 22;
    ctx.clearRect(0, 0, W, H);

    // Rounded background
    ctx.beginPath();
    ctx.moveTo(r, 0); ctx.lineTo(W - r, 0);
    ctx.quadraticCurveTo(W, 0, W, r);
    ctx.lineTo(W, H - r); ctx.quadraticCurveTo(W, H, W - r, H);
    ctx.lineTo(r, H);     ctx.quadraticCurveTo(0, H, 0, H - r);
    ctx.lineTo(0, r);     ctx.quadraticCurveTo(0, 0, r, 0);
    ctx.closePath();
    ctx.fillStyle = 'rgba(10, 10, 18, 0.88)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Rows
    const rows = [
      { img: icons[0], label: 'Trigger',    desc: 'Rotate' },
      { img: icons[1], label: 'Grip',       desc: 'Grab / Move' },
      { img: icons[2], label: 'Stick ← →', desc: 'Scale' },
      { img: icons[3], label: 'Stick ↑ ↓', desc: 'Push / Pull' },
    ];

    const rowH = (H - 28) / rows.length;
    rows.forEach((row, i) => {
      const y = 20 + i * rowH + rowH * 0.5;

      // SVG icon centred vertically in row
      ctx.drawImage(row.img, 10, y - ICON_SIZE / 2, ICON_SIZE, ICON_SIZE);

      ctx.font = 'bold 18px monospace';
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(row.label, 50, y - 8);

      ctx.font = '15px sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillText(row.desc, 50, y + 12);
    });

    texture.needsUpdate = true;
  }

  // Load all four icons, draw once all are ready
  const icons = [_iconTrigger, _iconGrip, _iconStickH, _iconStickV];
  let loaded = 0;
  icons.forEach(img => {
    if (img.complete) { if (++loaded === 4) drawPanel(icons); }
    else img.onload = () => { if (++loaded === 4) drawPanel(icons); };
  });

  const mat    = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(0.22, 0.11, 1);
  group.add(sprite);

  // ── Position helper — called once from 'connected' event ─────────────────
  group.userData.positionForHand = (handedness) => {
    const side = handedness === 'left' ? 1 : -1;
    group.position.set(side * 0.10, 0.07, 0.01);
    group.rotation.set(-Math.PI * 0.5, 0, side * Math.PI * 0.10);
  };

  return group;
}

// ── Build both controllers ─────────────────────────────────────────────────────

function buildController(index) {
  // Pointer space — laser lives here
  const pointer = renderer.xr.getController(index);
  pointer.add(makeLaser());
  scene.add(pointer);

  // Grip space — hardware model + mini-display live here
  const grip = renderer.xr.getControllerGrip(index);
  grip.add(controllerModelFactory.createControllerModel(grip));

  // Mini-display — rigid attachment, rotates 1:1 with the hand
  const miniDisplay = makeMiniDisplay();
  grip.add(miniDisplay);
  pointer.userData.miniDisplay    = miniDisplay;
  pointer.userData.prevAXPressed  = false;   // rising-edge state for A/X toggle

  scene.add(grip);

  return { pointer, grip };
}

const controllers = [buildController(0), buildController(1)];

// Wire gesture events on both controllers
for (let i = 0; i < controllers.length; i++) {
  const { pointer } = controllers[i];
  const slot = slots[i];

  pointer.addEventListener('connected', e => {
    pointer.userData.xrInputSource = e.data;
    pointer.userData.handedness    = e.data.handedness;   // 'left' | 'right'
    if (pointer.userData.miniDisplay?.userData.positionForHand) {
      pointer.userData.miniDisplay.userData.positionForHand(e.data.handedness);
    }
  });
  pointer.addEventListener('disconnected', () => { pointer.userData.xrInputSource = null; });

  pointer.addEventListener('squeezestart', () => {
    if (slot.type) return;
    const { hitPoint, hitEntry } = pointer.userData;
    if (!hitEntry) return;
    startGrab(slot, pointer, hitPoint, hitEntry);
  });
  pointer.addEventListener('squeezeend', () => {
    if (slot.type === 'grab') endInteraction(slot);
  });

  pointer.addEventListener('selectstart', () => {
    if (slot.type) return;
    const { hitPoint, hitEntry } = pointer.userData;
    if (!hitEntry) return;
    startRotate(slot, pointer, hitPoint, hitEntry);
  });
  pointer.addEventListener('selectend', () => {
    if (slot.type === 'rotate') endInteraction(slot);
  });
}


// ─── §9  XR session lifecycle — mode tracking, VR/MR buttons ─────────────────
//
// currentMode: 'browser' | 'vr' | 'mr'
//
// Both buttons manage their own session lifecycle manually so onXRSessionStart
// can be called directly with the correct mode — no side-channel flag needed.

let currentMode = 'browser';

const modeBadge   = document.getElementById('mode-badge');
const controlsBar = document.querySelector('.controls');

function setMode(mode) {
  currentMode = mode;
  modeBadge.className = '';
  if (mode === 'vr') { modeBadge.className = 'vr'; modeBadge.textContent = '● VR'; }
  if (mode === 'mr') { modeBadge.className = 'mr'; modeBadge.textContent = '● MR'; }
}

function onXRSessionStart(mode) {
  setMode(mode);

  // ── Flush OrbitControls damping before handing camera to XR ──────────────
  // Even with controls.enabled = false, controls.update() with dampingFactor
  // > 0 keeps applying residual momentum to camera.position every frame.
  // Drain that momentum NOW before the XR runtime takes ownership of the
  // camera, so there is zero leftover delta fighting the head-pose tracker.
  controls.saveState();           // snapshot so we can restore on session end
  controls.dampingFactor = 0;     // kill damping temporarily
  controls.update();              // one tick to flush pending delta to zero
  controls.dampingFactor = 0.06;  // restore (won't run again until session ends)
  controls.enabled = false;       // disable input handling

  gridHelper.visible = false;
  ground.visible = false;
  dirLight.castShadow = false;   // shadows off in XR — saves a full shadow map render every frame

  if (mode === 'mr') {
    // Transparent background → passthrough shows through
    scene.background = null;
    renderer.setClearColor(0x000000, 0);
    // Boost ambient slightly so model isn't too dark against bright room
    ambientLight.intensity = 1.2;
    mrShadowDisc.visible = true;
  } else {
    // VR: solid opaque black — gives the XR compositor a proper opaque layer.
    // null/transparent in VR causes the compositor to blend against undefined
    // content, contributing to silhouette-edge flicker.
    scene.background = new THREE.Color(0x000000);
    renderer.setClearColor(0x000000, 1);
    ambientLight.intensity = 0.6;
    mrShadowDisc.visible = false;
  }

  for (const entry of models) {
    const { mesh, pivot, root } = entry;
    scene.remove(mesh);
    root.add(mesh);
    // Re-centre so rotation pivots around model centre
    const box = new THREE.Box3().setFromObject(mesh);
    const centre = box.getCenter(new THREE.Vector3());
    mesh.position.sub(centre);

    // Size the orb to wrap the re-centred mesh in root-local space.
    // After re-centring, mesh bounding sphere centre ≈ root origin.
    // Radius is in root-local units (LDU) — root.scale handles world conversion.
    if (entry.orb && entry.orbSphere) {
      const bs = new THREE.Box3().setFromObject(mesh).getBoundingSphere(new THREE.Sphere());
      const r  = bs.radius * 1.05;   // 5% clearance so rings sit just outside
      entry.orbSphere.scale.setScalar(r);
      entry.orb.children.forEach((c, i) => { if (i > 0) c.scale.setScalar(r); });
    }
  }

  // Place pivots using the XR reference space viewer pose so we get the actual
  // floor-relative eye height, then position models just below eye level.
  // We poll every frame until the viewer pose is available (usually frame 1-2).
  const placePivots = () => {
    const frame    = renderer.xr.getFrame();
    const refSpace = renderer.xr.getReferenceSpace();
    if (!frame || !refSpace) { requestAnimationFrame(placePivots); return; }

    const pose = frame.getViewerPose(refSpace);
    if (!pose) { requestAnimationFrame(placePivots); return; }

    // local-floor gives Y=0 at floor. Place models at comfortable table height.
    let x = 0;
    for (const entry of models) {
      entry.pivot.position.set(x, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
      x += MODEL_SPACING;
    }
    if (mode === 'mr') mrShadowDisc.position.set(0, 0.02, MODEL_PIVOT_Z);
  };
  requestAnimationFrame(placePivots);
}

function onXRSessionEnd() {
  setMode('browser');

  // Drop all active interactions and reset laser colors
  for (const slot of slots) endInteraction(slot);
  for (const { pointer } of controllers) {
    setLaserColor(pointer, COLOR_IDLE);
    pointer.userData.hitPoint      = null;
    pointer.userData.hitEntry      = null;
    pointer.userData.xrInputSource = null;
    pointer.userData.prevBYPressed = false;
  }

  // Restore OrbitControls to the exact state they were in before XR started
  controls.reset();       // returns to saveState() snapshot
  controls.enabled = true;

  // Restore browser visuals
  scene.background = BROWSER_BG;
  renderer.setClearColor(0x000000, 1);
  ambientLight.intensity = 0.6;
  gridHelper.visible = document.getElementById('toggle-grid').classList.contains('on');
  ground.visible = true;
  dirLight.castShadow = true;
  mrShadowDisc.visible = false;

  // Return all models to scene root
  for (const entry of models) {
    const { mesh, pivot, root } = entry;
    root.remove(mesh);
    mesh.position.set(0, 0, 0);
    scene.add(mesh);
    // Reset XR transforms for next session
    root.scale.setScalar(LDU_TO_METERS);
    root.rotation.set(0, 0, 0);
  }
  if (models.length > 0) fitCamera();
}

renderer.xr.addEventListener('sessionend', onXRSessionEnd);

// ── Shared session-request options ────────────────────────────────────────────
const XR_SESSION_OPTS = {
  requiredFeatures: ['local-floor'],
  optionalFeatures: ['bounded-floor', 'hand-tracking'],
};

// ── VR button ─────────────────────────────────────────────────────────────────

function makeXRButton(label, className) {
  const btn = document.createElement('button');
  btn.className = className;
  btn.textContent = label;
  btn.disabled = true;
  return btn;
}

const vrButton = makeXRButton('ENTER VR', 'btn xr-btn');

if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-vr').then(supported => {
    vrButton.disabled = !supported;
    vrButton.textContent = supported ? 'ENTER VR' : 'VR NOT SUPPORTED';
  }).catch(() => { vrButton.disabled = true; vrButton.textContent = 'VR NOT SUPPORTED'; });

  let vrSession = null;
  vrButton.addEventListener('click', () => {
    if (vrSession === null) {
      navigator.xr.requestSession('immersive-vr', XR_SESSION_OPTS)
        .then(session => {
          renderer.xr.setSession(session);
          onXRSessionStart('vr');
          vrSession = session;
          vrButton.textContent = 'EXIT VR';
          vrButton.classList.add('btn-danger');
          session.addEventListener('end', () => {
            vrSession = null;
            vrButton.textContent = 'ENTER VR';
            vrButton.classList.remove('btn-danger');
          });
        }).catch(err => console.error('VR session request failed:', err));
    } else {
      vrSession.end();
    }
  });
} else {
  vrButton.textContent = 'VR NOT SUPPORTED';
}

controlsBar.prepend(vrButton);

// ── MR button ─────────────────────────────────────────────────────────────────

const mrButton = makeXRButton('ENTER MR', 'btn xr-btn-mr');

if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-ar').then(supported => {
    mrButton.disabled = !supported;
    mrButton.textContent = supported ? 'ENTER MR' : 'MR NOT SUPPORTED';
  }).catch(() => { mrButton.disabled = true; mrButton.textContent = 'MR NOT SUPPORTED'; });

  let mrSession = null;
  mrButton.addEventListener('click', () => {
    if (mrSession === null) {
      navigator.xr.requestSession('immersive-ar', XR_SESSION_OPTS)
        .then(session => {
          renderer.xr.setSession(session);
          onXRSessionStart('mr');
          mrSession = session;
          mrButton.textContent = 'EXIT MR';
          mrButton.classList.add('btn-danger');
          session.addEventListener('end', () => {
            mrSession = null;
            mrButton.textContent = 'ENTER MR';
            mrButton.classList.remove('btn-danger');
          });
        }).catch(err => console.error('MR session request failed:', err));
    } else {
      mrSession.end();
    }
  });
} else {
  mrButton.textContent = 'MR NOT SUPPORTED';
}

vrButton.insertAdjacentElement('afterend', mrButton);

// ── Animation loop ────────────────────────────────────────────────────────────
// IMPORTANT: controls.update() must NOT run while XR is presenting.
// The XR runtime owns the camera pose during a session. If OrbitControls
// also runs update() every frame — even with enabled=false, the damping
// momentum still nudges camera.position — it fights the XR pose tracker
// and produces the rapid head-movement jitter.
renderer.setAnimationLoop((timestamp, frame) => {
  if (renderer.xr.isPresenting && frame) {
    updateXRControls();
  } else {
    controls.update(); // only touch the camera in browser mode
  }
  renderer.render(scene, camera);
});


// ─── §10  Model data ──────────────────────────────────────────────────────────
//
// fetchModelList — fetches the JSONL index, parses new-format records
// (description / categories / keywords) with graceful fallback for old ones.
// Builds the Fuse instance used by the gallery search.

let mbModels = [];   // [{ name, description, categories, keywords, url, thumb }]
let mbFuse   = null; // Fuse instance, built after model list loads

async function fetchModelList() {
  try {
    const res = await fetch(MODELS_INDEX);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();

    mbModels = text
      .split('\n')
      .filter(line => line.trim())
      .map(line => {
        const rec         = JSON.parse(line);
        const description = rec.description ?? rec.search_key ?? rec.name;
        const categories  = rec.categories?.length ? rec.categories : ['Other'];
        const keywords    = rec.keywords ?? [];
        // Strip .zip suffix for display name and thumbnail — the zip contains
        // a single file whose name is rec.name minus the .zip extension.
        const baseName    = rec.name.replace(/\.zip$/i, '');
        return {
          name:        rec.name,   // original index name (may end in .zip) — used for the fetch URL
          displayName: baseName,   // .zip stripped — shown in UI and passed to onModelLoaded
          description,
          categories,
          keywords,
          url:   RAW_BASE   + encodeURIComponent(rec.name),
          thumb: THUMB_BASE + encodeURIComponent(baseName.replace(/\.[^.]+$/, '.png')),
        };
      });

    mbFuse = new Fuse(mbModels, {
      keys: [
        { name: 'description', weight: 3   },
        { name: 'categories',  weight: 2   },
        { name: 'keywords',    weight: 1.5 },
        { name: 'name',        weight: 1   },
      ],
      threshold:          0.35,
      distance:           200,
      minMatchCharLength: 1,
      includeScore:       true,
      includeMatches:     true,
    });

    // If gallery is already open (user clicked Browse before index loaded), refresh it
    if (galleryOverlay.classList.contains('open')) openGallery();

  } catch (err) {
    console.warn('Model list fetch failed:', err);
  }
}
fetchModelList();

function loadFromBrowser(url, name) {
  closeGallery();
  showLoading('Loading model…', name);
  loadModelFromURL(url, name, 'Could not load model.');
}

function escHtml(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function highlightField(text, matches, key) {
  if (!text) return '';
  if (!matches?.length) return escHtml(text);

  const marked = new Set();
  for (const m of matches) {
    if (m.key === key) {
      for (const [start, end] of m.indices) {
        for (let i = start; i <= end; i++) marked.add(i);
      }
    }
  }
  if (marked.size === 0) return escHtml(text);

  let html = '', inMark = false;
  for (let i = 0; i < text.length; i++) {
    if ( marked.has(i) && !inMark) { html += '<mark>'; inMark = true;  }
    if (!marked.has(i) &&  inMark) { html += '</mark>'; inMark = false; }
    html += escHtml(text[i]);
  }
  if (inMark) html += '</mark>';
  return html;
}


// ─── §10b  Gallery ────────────────────────────────────────────────────────────
//
// Single entry point: openGallery() — no arguments, always shows all models.
// Gallery has its own fuzzy search (no minimum character requirement).
// Category filter sidebar sorted alphabetically, first letter uppercased.
// Cards are 200×220px, 4 columns, lazy thumbnails via IntersectionObserver.

const galleryOverlay    = document.getElementById('model-gallery');
const galleryGridEl     = document.getElementById('gallery-grid');
const galleryStatusEl   = document.getElementById('gallery-status');
const galleryFiltersEl  = document.getElementById('gallery-filters');
const galleryLoadMoreEl = document.getElementById('gallery-load-more-wrap');
const gallerySearchEl   = document.getElementById('gallery-search-input');

// ── State ──────────────────────────────────────────────────────────────────────
let _gallerySourceResults    = [];  // current Fuse results (or wrapped full list)
let _galleryFiltered         = [];  // after category filter + sort
let _galleryPage             = 0;
let _galleryObserver         = null;
let _galleryActiveCategories = new Set();  // empty = show all

// ── Helpers ────────────────────────────────────────────────────────────────────

// Wrap plain model objects into Fuse-result shape so downstream code is uniform.
function _wrapModels(models) {
  return models.map(item => ({ item, score: 1, matches: [] }));
}

function _capFirst(s) {
  return s ? s.charAt(0).toUpperCase() + s.slice(1) : s;
}

// ── Open / close ───────────────────────────────────────────────────────────────

function openGallery() {
  if (renderer.xr.isPresenting) return;
  gallerySearchEl.value    = '';
  _galleryActiveCategories = new Set();
  galleryOverlay.classList.add('open');

  if (mbModels.length === 0) {
    // Index not yet loaded — fetchModelList() will call openGallery() again when ready
    galleryStatusEl.textContent     = 'Loading model list…';
    galleryGridEl.innerHTML         = '<div class="gallery-empty">Fetching model index…</div>';
    galleryFiltersEl.innerHTML      = '';
    galleryLoadMoreEl.style.display = 'none';
    return;
  }

  _gallerySourceResults = _wrapModels(mbModels);
  _buildCategoryFilters(_gallerySourceResults);
  _applyGalleryFilters();
  requestAnimationFrame(() => gallerySearchEl.focus());
}

function closeGallery() {
  galleryOverlay.classList.remove('open');
  _galleryObserver?.disconnect();
  _galleryObserver        = null;
  galleryGridEl.innerHTML = '';
  galleryLoadMoreEl.style.display = 'none';
}

// ── Category filters ───────────────────────────────────────────────────────────

function _buildCategoryFilters(results) {
  const counts = new Map();
  for (const r of results) {
    for (const cat of (r.item.categories ?? ['Other'])) {
      const key = _capFirst(cat);
      counts.set(key, (counts.get(key) ?? 0) + 1);
    }
  }

  // Alphabetical order
  const sorted = [...counts.entries()].sort((a, b) => a[0].localeCompare(b[0]));

  galleryFiltersEl.innerHTML = sorted.map(([cat, n]) =>
    `<label class="gallery-filter-item">` +
      `<input type="checkbox" class="gallery-cat-cb" value="${escHtml(cat)}">` +
      `<span class="gallery-filter-label">${escHtml(cat)}</span>` +
      `<span class="gallery-filter-count">${n}</span>` +
    `</label>`
  ).join('');

  galleryFiltersEl.querySelectorAll('.gallery-cat-cb').forEach(cb => {
    cb.addEventListener('change', () => {
      if (cb.checked) _galleryActiveCategories.add(cb.value);
      else            _galleryActiveCategories.delete(cb.value);
      _applyGalleryFilters();
    });
  });
}

// ── Filter + sort ──────────────────────────────────────────────────────────────

function _applyGalleryFilters() {
  let items = _gallerySourceResults;

  if (_galleryActiveCategories.size > 0) {
    items = items.filter(r =>
      (r.item.categories ?? ['Other'])
        .some(c => _galleryActiveCategories.has(_capFirst(c)))
    );
  }

  const sortVal = document.querySelector('input[name="gallery-sort"]:checked')?.value ?? 'relevance';
  if (sortVal === 'name') {
    items = [...items].sort((a, b) =>
      (a.item.description ?? a.item.name).localeCompare(b.item.description ?? b.item.name)
    );
  }

  _galleryFiltered = items;
  _galleryPage     = 0;
  galleryGridEl.innerHTML = '';
  _galleryObserver?.disconnect();
  _galleryObserver = new IntersectionObserver(_onThumbVisible, { rootMargin: '120px' });

  _renderGalleryPage();

  const n = _galleryFiltered.length;
  galleryStatusEl.textContent = n + ' model' + (n !== 1 ? 's' : '');
}

// ── Render a page of cards ─────────────────────────────────────────────────────

function _renderGalleryPage() {
  const start = _galleryPage * GALLERY_PAGE_SIZE;
  const slice = _galleryFiltered.slice(start, start + GALLERY_PAGE_SIZE);

  if (slice.length === 0 && _galleryPage === 0) {
    galleryGridEl.innerHTML         = '<div class="gallery-empty">No models match the current filters.</div>';
    galleryLoadMoreEl.style.display = 'none';
    return;
  }

  for (const r of slice) {
    const { name, displayName, description, url, thumb, categories, keywords } = r.item;
    const card       = document.createElement('div');
    card.className   = 'gallery-card';
    card.tabIndex    = 0;
    card.dataset.url   = url;
    card.dataset.name  = description || displayName;
    card.dataset.thumb = thumb;

    const catsHtml = `<div class="gallery-card-cats">` +
      `<span class="gallery-card-field-label">CAT</span>` +
      escHtml((categories ?? ['Other']).join(', ')) +
      `</div>`;

    const kwdHtml = (keywords?.length)
      ? `<div class="gallery-card-kwd">` +
          `<span class="gallery-card-field-label">KWD</span>` +
          escHtml(keywords.join(', ')) +
        `</div>`
      : '';

    card.innerHTML =
      `<div class="gallery-card-thumb-wrap">` +
        `<div class="gallery-card-placeholder"></div>` +
      `</div>` +
      `<div class="gallery-card-info">` +
        `<div class="gallery-card-name">${escHtml(description || displayName)}</div>` +
        `<div class="gallery-card-file">${escHtml(displayName)}</div>` +
        catsHtml +
        kwdHtml +
      `</div>`;

    card.addEventListener('click',   () => loadFromBrowser(card.dataset.url, card.dataset.name));
    card.addEventListener('keydown', e  => { if (e.key === 'Enter') card.click(); });
    galleryGridEl.appendChild(card);
    _galleryObserver.observe(card);
  }

  const hasMore = (start + GALLERY_PAGE_SIZE) < _galleryFiltered.length;
  galleryLoadMoreEl.style.display = hasMore ? 'flex' : 'none';
}

// ── Lazy thumbnail loading ─────────────────────────────────────────────────────

function _onThumbVisible(entries) {
  for (const entry of entries) {
    if (!entry.isIntersecting) continue;
    const card = entry.target;
    _galleryObserver.unobserve(card);

    const wrap  = card.querySelector('.gallery-card-thumb-wrap');
    const thumb = card.dataset.thumb;
    if (!thumb) continue;

    const img     = document.createElement('img');
    img.className = 'gallery-card-thumb';
    img.alt       = card.dataset.name;
    img.onload    = () => { img.classList.add('loaded'); wrap.querySelector('.gallery-card-placeholder')?.remove(); };
    img.onerror   = () => img.remove();
    img.src       = thumb;
    wrap.appendChild(img);
  }
}

// ── Gallery search — no minimum character requirement ─────────────────────────

let _gallerySearchTimer = null;

gallerySearchEl.addEventListener('input', () => {
  clearTimeout(_gallerySearchTimer);
  _gallerySearchTimer = setTimeout(() => {
    const q = gallerySearchEl.value.trim();

    if (!q) {
      _gallerySourceResults = _wrapModels(mbModels);
    } else {
      if (!mbFuse) return;
      _gallerySourceResults = mbFuse.search(q);
    }

    // Rebuild filters for new result set, preserving any checked categories that still apply
    const prevActive = new Set(_galleryActiveCategories);
    _buildCategoryFilters(_gallerySourceResults);
    _galleryActiveCategories = new Set();
    galleryFiltersEl.querySelectorAll('.gallery-cat-cb').forEach(cb => {
      if (prevActive.has(cb.value)) { cb.checked = true; _galleryActiveCategories.add(cb.value); }
    });

    _applyGalleryFilters();
  }, 200);
});

// ── Event wiring ───────────────────────────────────────────────────────────────

document.getElementById('btn-gallery-close').addEventListener('click', closeGallery);
galleryOverlay.addEventListener('click', e => { if (e.target === galleryOverlay) closeGallery(); });
document.getElementById('btn-gallery-load-more').addEventListener('click', () => {
  _galleryPage++;
  _renderGalleryPage();
  document.getElementById('gallery-main').scrollBy({ top: 400, behavior: 'smooth' });
});
document.querySelectorAll('input[name="gallery-sort"]').forEach(radio => {
  radio.addEventListener('change', _applyGalleryFilters);
});


// ─── §11  UI helpers + DOM references ────────────────────────────────────────

const dropZone         = document.getElementById('drop-zone');
const loadingOverlay   = document.getElementById('loading-overlay');
const loadingMsg       = document.getElementById('loading-msg');
const loadingSub       = document.getElementById('loading-sub');
const statusEl         = document.getElementById('status');
const errorBanner      = document.getElementById('error-banner');
const errorText        = document.getElementById('error-text');
const sceneCountEl     = document.getElementById('scene-count');
const sceneModelListEl = document.getElementById('scene-model-list');

function showLoading(msg, sub) {
  loadingMsg.textContent = msg || 'Loading…';
  loadingSub.textContent = sub || '';
  loadingOverlay.classList.add('visible');
  errorBanner.classList.remove('visible');
}
function hideLoading() { loadingOverlay.classList.remove('visible'); }
function showError(msg) { hideLoading(); errorText.textContent = msg; errorBanner.classList.add('visible'); }
function setStatus(s)   { statusEl.textContent = s; }


// ─── §12  UI event wiring ─────────────────────────────────────────────────────
// All HTML→JS connections in one place; no onclick attributes in the markup.

// Header buttons
document.getElementById('btn-demo').addEventListener('click', () => {
  showLoading('Loading demo…', 'Fetching packed .mpd from GitHub');
  loadModelFromURL(DEMO_MODEL, 'car (demo)', 'Could not load demo — check your internet connection.');
});
document.getElementById('btn-browse').addEventListener('click', openGallery);
document.getElementById('btn-reset-view').addEventListener('click', resetView);
document.getElementById('btn-open-file').addEventListener('click', () => document.getElementById('file-input').click());

// File input & drag-drop
document.getElementById('file-input').addEventListener('change', function() {
  if (this.files[0]) loadFile(this.files[0]);
  this.value = '';
});
container.addEventListener('dragover',  e => { e.preventDefault(); dropZone.classList.add('dragging'); });
container.addEventListener('dragleave', () => dropZone.classList.remove('dragging'));
container.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragging');
  if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
});
dropZone.addEventListener('click', () => document.getElementById('file-input').click());

// Sidebar controls
document.getElementById('btn-load-url').addEventListener('click', loadFromURL);
document.getElementById('toggle-edges').addEventListener('click', toggleEdges);
document.getElementById('toggle-grid').addEventListener('click', toggleGrid);
// Delegated remove — one listener handles all ✕ buttons in the scene model list
sceneModelListEl.addEventListener('click', e => {
  const btn = e.target.closest('.model-list-remove');
  if (btn) removeEntry(models[+btn.dataset.idx]);
});

// Error banner
document.getElementById('btn-error-close').addEventListener('click', () => errorBanner.classList.remove('visible'));

// Canvas — double-click to focus orbit target on clicked point
renderer.domElement.addEventListener('dblclick', e => {
  if (models.length === 0 || renderer.xr.isPresenting) return;
  const hit = browserRaycast(e.clientX, e.clientY);
  if (hit) { controls.target.copy(hit.point); controls.update(); }
});

// Canvas — pointer events for drag, select, deselect
renderer.domElement.addEventListener('pointerdown', e => {
  if (renderer.xr.isPresenting || models.length === 0) return;
  _pointerDownPos = { x: e.clientX, y: e.clientY };

  const hit   = browserRaycast(e.clientX, e.clientY);
  const entry = hit ? hitToEntry(hit) : null;

  if (e.button === 2 && entry) {
    e.preventDefault();
    selectEntry(entry);
    startDrag(entry, e.clientX, e.clientY);
    return;
  }

  if (e.button === 0 && entry) {
    selectEntry(entry);
    container.classList.add('drag-ready');
    _holdTimer = setTimeout(() => {
      if (_pointerDownPos) startDrag(entry, _pointerDownPos.x, _pointerDownPos.y);
    }, 150);
  }
});

renderer.domElement.addEventListener('pointermove', e => {
  if (renderer.xr.isPresenting) return;
  if (_dragActive) { moveDrag(e.clientX, e.clientY); return; }
  if (models.length > 0) {
    container.classList.toggle('drag-ready', !!browserRaycast(e.clientX, e.clientY));
  }
});

renderer.domElement.addEventListener('pointerup', e => {
  if (renderer.xr.isPresenting) return;
  if (_holdTimer) { clearTimeout(_holdTimer); _holdTimer = null; }
  container.classList.remove('drag-ready');
  _pointerDownPos = null;
  if (_dragActive) { endDrag(); return; }
  if (e.button === 0) {
    const hit = browserRaycast(e.clientX, e.clientY);
    if (!hit) { selectedEntry = null; renderModelList(); }
  }
});

renderer.domElement.addEventListener('pointercancel', endDrag);
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault()); // allow right-drag

// Keyboard — nudge selected model (browser) or navigate model browser (overlay)
document.addEventListener('keydown', e => {
  // Model browser keyboard nav takes priority when open
  if (e.key === 'Escape' && galleryOverlay.classList.contains('open')) {
    closeGallery(); return;
  }

  // Arrow-key nudge for the selected model
  if (renderer.xr.isPresenting || !selectedEntry) return;
  if (document.activeElement?.tagName === 'INPUT') return;
  let moved = true;
  switch (e.key) {
    case 'ArrowLeft':  selectedEntry.mesh.position.x -= NUDGE_STEP; break;
    case 'ArrowRight': selectedEntry.mesh.position.x += NUDGE_STEP; break;
    case 'ArrowUp':    selectedEntry.mesh.position.z -= NUDGE_STEP; break;
    case 'ArrowDown':  selectedEntry.mesh.position.z += NUDGE_STEP; break;
    default: moved = false;
  }
  if (moved) { clampToFloor(selectedEntry.mesh); e.preventDefault(); }
});

</script>

<!-- ─── Gallery overlay ─────────────────────────────────────────────────────── -->
<div id="model-gallery">
  <div class="gallery-topbar">
    <span class="gallery-topbar-title">Gallery</span>
    <div class="gallery-search-wrap">
      <span class="gallery-search-icon">⌕</span>
      <input
        type="text"
        class="gallery-search"
        id="gallery-search-input"
        placeholder="Filter gallery (3+ chars)…"
        autocomplete="off"
        spellcheck="false"
      >
    </div>
    <span class="gallery-status" id="gallery-status"></span>
    <button class="btn btn-danger" id="btn-gallery-close" title="Close gallery">Close</button>
  </div>
  <div class="gallery-body">
    <div class="gallery-sidebar">
      <div>
        <div class="gallery-filter-title">Category</div>
        <div id="gallery-filters"></div>
      </div>
      <div>
        <div class="gallery-filter-title">Sort by</div>
        <label class="gallery-sort-item">
          <input type="radio" name="gallery-sort" value="relevance" checked> <span class="gallery-sort-label">Relevance</span>
        </label>
        <label class="gallery-sort-item">
          <input type="radio" name="gallery-sort" value="name"> <span class="gallery-sort-label">Name A→Z</span>
        </label>
      </div>
    </div>
    <div class="gallery-main" id="gallery-main">
      <div class="gallery-grid" id="gallery-grid"></div>
      <div class="gallery-load-more-wrap" id="gallery-load-more-wrap" style="display:none">
        <button class="gallery-load-more" id="btn-gallery-load-more">Load more</button>
      </div>
    </div>
  </div>
</div>
</body>
</html>
