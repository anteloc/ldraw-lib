<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LDraw Model Viewer v5</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;800&display=swap');
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --panel: #16161a; --border: #2a2a30;
    --accent: #ffcc00; --accent-mr: #00ddff; --text: #e8e8ec; --muted: #6b6b78;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Syne', sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
  header { display: flex; align-items: center; justify-content: space-between; padding: 12px 24px; border-bottom: 1px solid var(--border); background: var(--panel); flex-shrink: 0; }
  .logo { display: flex; align-items: center; gap: 10px; }
  .logo-brick { width: 28px; height: 20px; background: var(--accent); border-radius: 2px; position: relative; }
  .logo-brick::before, .logo-brick::after { content: ''; position: absolute; top: -7px; width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
  .logo-brick::before { left: 4px; } .logo-brick::after { right: 4px; }
  .logo h1 { font-size: 16px; font-weight: 800; letter-spacing: .05em; text-transform: uppercase; }
  .logo span { color: var(--accent); }
  .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .btn { font-family: 'Space Mono', monospace; font-size: 11px; padding: 7px 14px; border-radius: 4px; border: 1px solid var(--border); background: transparent; color: var(--text); cursor: pointer; text-transform: uppercase; letter-spacing: .08em; transition: all .15s; white-space: nowrap; }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn.primary { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
  .btn.primary:hover { background: #ffd633; }
  /* MR button gets a cyan accent */
  .btn.mr-btn { border-color: var(--accent-mr); color: var(--accent-mr); }
  .btn.mr-btn:hover { background: var(--accent-mr); color: #000; }
  .btn.mr-btn:disabled { border-color: var(--border); color: var(--muted); cursor: not-allowed; }
  .workspace { flex: 1; display: flex; overflow: hidden; }
  #canvas-container { flex: 1; position: relative; background: radial-gradient(ellipse at center, #1a1a2e 0%, #0e0e10 70%); }
  canvas { display: block; }
  .sidebar { width: 220px; background: var(--panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; flex-shrink: 0; overflow-y: auto; }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); }
  .sidebar-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: .15em; color: var(--muted); margin-bottom: 12px; }
  .info-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 6px; font-family: 'Space Mono', monospace; }
  .info-row .label { color: var(--muted); }
  .info-row .value { color: var(--text); }
  .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
  .toggle-label { font-size: 11px; font-family: 'Space Mono', monospace; text-transform: uppercase; letter-spacing: .05em; }
  .toggle { width: 34px; height: 18px; background: var(--border); border-radius: 9px; cursor: pointer; position: relative; transition: background .2s; }
  .toggle.on { background: var(--accent); }
  .toggle::after { content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: left .2s; }
  .toggle.on::after { left: 18px; }
  .hint { font-size: 10px; color: var(--muted); font-family: 'Space Mono', monospace; line-height: 1.8; }
  .hint b { color: var(--text); }
  .url-input { width: 100%; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 7px 8px; color: var(--text); font-family: 'Space Mono', monospace; font-size: 10px; margin-bottom: 6px; outline: none; }
  .url-input:focus { border-color: var(--accent); }
  .url-input::placeholder { color: var(--muted); }
  #drop-zone { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; cursor: pointer; }
  .drop-icon { width: 80px; height: 56px; border: 2px dashed var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; transition: all .2s; }
  .drop-zone-brick { width: 36px; height: 24px; background: var(--border); border-radius: 2px; position: relative; transition: background .2s; }
  .drop-zone-brick::before, .drop-zone-brick::after { content: ''; position: absolute; top: -9px; width: 10px; height: 10px; background: var(--border); border-radius: 50%; transition: background .2s; }
  .drop-zone-brick::before { left: 5px; } .drop-zone-brick::after { right: 5px; }
  .drop-text { text-align: center; }
  .drop-text h2 { font-size: 15px; font-weight: 600; }
  .drop-text p { font-size: 11px; color: var(--muted); font-family: 'Space Mono', monospace; margin-top: 4px; }
  #drop-zone.dragging .drop-icon, #drop-zone:hover .drop-icon { border-color: var(--accent); }
  #drop-zone.dragging .drop-zone-brick, #drop-zone:hover .drop-zone-brick,
  #drop-zone.dragging .drop-zone-brick::before, #drop-zone.dragging .drop-zone-brick::after,
  #drop-zone:hover .drop-zone-brick::before, #drop-zone:hover .drop-zone-brick::after { background: var(--accent); }
  #loading-overlay { display: none; position: absolute; inset: 0; background: rgba(14,14,16,.8); align-items: center; justify-content: center; flex-direction: column; gap: 14px; }
  #loading-overlay.visible { display: flex; }
  .spinner { width: 32px; height: 32px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-family: 'Space Mono', monospace; font-size: 12px; color: var(--text); }
  .loading-sub { font-family: 'Space Mono', monospace; font-size: 10px; color: var(--muted); max-width: 280px; text-align: center; line-height: 1.6; }
  #status { position: absolute; bottom: 16px; left: 16px; font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted); pointer-events: none; }
  /* Mode badge — shown in VR/MR so user knows what mode they entered */
  #mode-badge { position: absolute; top: 16px; right: 16px; font-family: 'Space Mono', monospace; font-size: 10px; padding: 4px 10px; border-radius: 3px; display: none; pointer-events: none; }
  #mode-badge.vr { display: block; background: rgba(255,204,0,.15); border: 1px solid var(--accent); color: var(--accent); }
  #mode-badge.mr { display: block; background: rgba(0,221,255,.15); border: 1px solid var(--accent-mr); color: var(--accent-mr); }
  #file-input { display: none; }
  .error-banner { display: none; position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: #2a1010; border: 1px solid #663333; border-radius: 6px; padding: 12px 20px; max-width: 420px; width: 90%; z-index: 10; }
  .error-banner.visible { display: flex; align-items: flex-start; gap: 10px; }
  .error-banner-text { flex: 1; font-size: 11px; font-family: 'Space Mono', monospace; color: #ff8888; line-height: 1.6; white-space: pre-wrap; }
  .error-close { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 16px; line-height: 1; padding: 0; flex-shrink: 0; }
  /* MR shadow catcher — a subtle disc under the model in MR */
  /* (handled via Three.js object, no CSS needed) */

  /* ─── Model Browser Overlay ─────────────────────────────────────────────── */
  #model-browser {
    display: none;
    position: fixed; inset: 0; z-index: 100;
    background: rgba(8,8,10,.85);
    backdrop-filter: blur(6px);
    align-items: flex-start; justify-content: center;
    padding-top: 80px;
  }
  #model-browser.open { display: flex; }

  .mb-panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    width: 560px; max-width: 95vw;
    max-height: 70vh;
    display: flex; flex-direction: column;
    box-shadow: 0 24px 64px rgba(0,0,0,.6);
    overflow: hidden;
  }

  .mb-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .mb-title {
    font-size: 11px; font-weight: 700; text-transform: uppercase;
    letter-spacing: .15em; color: var(--muted);
  }
  .mb-close {
    background: none; border: none; color: var(--muted);
    cursor: pointer; font-size: 18px; line-height: 1; padding: 0;
    transition: color .15s;
  }
  .mb-close:hover { color: var(--text); }

  .mb-search-wrap {
    padding: 14px 20px 10px;
    flex-shrink: 0;
    position: relative;
  }
  .mb-search {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 10px 14px 10px 36px;
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    outline: none;
    transition: border-color .15s;
  }
  .mb-search:focus { border-color: var(--accent); }
  .mb-search::placeholder { color: var(--muted); }
  .mb-search-icon {
    position: absolute; left: 33px; top: 50%; transform: translateY(-50%);
    color: var(--muted); font-size: 14px; pointer-events: none;
  }

  .mb-status {
    padding: 0 20px 8px;
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    flex-shrink: 0;
    min-height: 22px;
  }

  .mb-results {
    flex: 1; overflow-y: auto;
    padding: 0 12px 12px;
  }
  /* Custom scrollbar */
  .mb-results::-webkit-scrollbar { width: 4px; }
  .mb-results::-webkit-scrollbar-track { background: transparent; }
  .mb-results::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .mb-result {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 12px;
    border-radius: 4px;
    border: 1px solid transparent;
    cursor: pointer;
    transition: all .12s;
    margin-bottom: 4px;
    gap: 12px;
  }
  .mb-result:hover { background: rgba(255,255,255,.04); border-color: var(--border); }
  .mb-result.focused { background: rgba(255,204,0,.07); border-color: rgba(255,204,0,.3); }

  .mb-result-name {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text);
    line-height: 1.4;
  }
  .mb-result-filename {
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    color: var(--muted);
    line-height: 1.3;
  }
  .mb-result-label {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 1px;
    min-width: 0;
    word-break: break-all;
  }
  /* Fuse.js highlight spans injected into name and filename */
  .mb-result-name mark,
  .mb-result-filename mark {
    background: none;
    color: var(--accent);
    font-weight: 700;
  }

  .mb-load-btn {
    font-family: 'Space Mono', monospace; font-size: 10px;
    padding: 5px 10px; border-radius: 3px;
    border: 1px solid var(--border); background: transparent;
    color: var(--muted); cursor: pointer; white-space: nowrap;
    transition: all .12s; flex-shrink: 0;
  }
  .mb-result:hover .mb-load-btn,
  .mb-result.focused .mb-load-btn { border-color: var(--accent); color: var(--accent); }

  .mb-empty {
    text-align: center; padding: 32px 20px;
    font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted);
    line-height: 1.8;
  }

  .mb-loading-indicator {
    text-align: center; padding: 24px;
    font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted);
  }

  /* ─── Scene model list ───────────────────────────────────────────────────── */
  .model-list-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 0; gap: 8px; border-bottom: 1px solid var(--border);
  }
  .model-list-item:last-child { border-bottom: none; }
  .model-list-name {
    font-family: 'Space Mono', monospace; font-size: 10px; color: var(--text);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .model-list-remove {
    background: none; border: none; color: var(--muted); cursor: pointer;
    font-size: 14px; line-height: 1; padding: 0 2px; flex-shrink: 0;
    transition: color .15s;
  }
  .model-list-remove:hover { color: #ff5555; }
  .model-list-empty {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); font-style: italic;
  }
  .model-list-count {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); margin-bottom: 8px;
  }
  .model-list-item.selected .model-list-name { color: var(--accent); }
  .model-list-item.selected { border-color: rgba(255,204,0,.25); }
  /* Show move cursor when hovering canvas in drag-ready state */
  #canvas-container.drag-ready  { cursor: grab; }
  #canvas-container.drag-active { cursor: grabbing; }

  /* ─── XR buttons (VR + MR) injected by JS ───────────────────────────────── */
  .btn.xr-btn, .btn.xr-btn-mr {
    position: static !important;
    width: auto !important; bottom: auto !important;
    left: auto !important;  right: auto !important;
  }
  .btn.xr-btn    { border-color: var(--border);    color: var(--text); }
  .btn.xr-btn-mr { border-color: var(--accent-mr); color: var(--accent-mr); }
  .btn.xr-btn:hover    { border-color: var(--accent); color: var(--accent); background: var(--border); }
  .btn.xr-btn-mr:hover { border-color: var(--accent-mr); color: #000; background: var(--accent-mr); }
  .btn.xr-btn:disabled, .btn.xr-btn-mr:disabled { border-color: var(--border); color: var(--muted); cursor: not-allowed; }

</style>
</head>
<body>

<header>
  <div class="logo">
    <div class="logo-brick"></div>
    <h1>LDraw <span>Viewer</span> <span style="font-size:11px;opacity:.4;color:var(--text)">v5</span></h1>
  </div>
  <div class="controls">
    <button class="btn" id="btn-demo">Load Demo</button>
    <button class="btn" id="btn-browse">Browse Models</button>
    <button class="btn" id="btn-reset-view">Reset View</button>
    <button class="btn primary" id="btn-open-file">Open File</button>
    <input type="file" id="file-input" accept=".ldr,.mpd,.dat">
    <!-- VR and MR buttons are injected here by JS after checking support -->
  </div>
</header>

<div class="workspace">
  <div id="canvas-container">
    <div id="drop-zone">
      <div class="drop-icon"><div class="drop-zone-brick"></div></div>
      <div class="drop-text">
        <h2>Drop LDraw File</h2>
        <p>.ldr &nbsp;·&nbsp; .mpd &nbsp;·&nbsp; .dat</p>
        <p style="margin-top:10px;font-size:10px;opacity:.6">Packed .mpd files work best<br>sub-parts are self-contained</p>
      </div>
    </div>
    <div id="loading-overlay">
      <div class="spinner"></div>
      <div class="loading-text" id="loading-msg">Loading…</div>
      <div class="loading-sub" id="loading-sub"></div>
    </div>
    <div class="error-banner" id="error-banner">
      <div class="error-banner-text" id="error-text"></div>
      <button class="error-close" id="btn-error-close">✕</button>
    </div>
    <div id="mode-badge"></div>
    <div id="status">No model loaded</div>
  </div>

  <div class="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">Scene</div>
      <div class="model-list-count" id="scene-count">No models loaded</div>
      <div id="scene-model-list"><span class="model-list-empty">—</span></div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Display</div>
      <div class="toggle-row">
        <span class="toggle-label">Edges</span>
        <div class="toggle on" id="toggle-edges"></div>
      </div>
      <div class="toggle-row">
        <span class="toggle-label">Grid</span>
        <div class="toggle on" id="toggle-grid"></div>
      </div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Load URL</div>
      <input type="text" class="url-input" id="url-input" placeholder="https://…/model.mpd">
      <button class="btn" id="btn-load-url" style="width:100%;margin-top:2px">Load</button>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Browser Controls</div>
      <div class="hint">
        Left drag — Orbit<br>
        Right drag — Pan camera<br>
        Scroll — Zoom<br>
        Double-click — Focus<br>
        <br>
        <b>Move a model:</b><br>
        Right-drag on model<br>
        Click model, then<br>
        arrow keys to nudge
      </div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">VR / MR Controls</div>
      <div class="hint">
        Aim at a model, then:<br>
        <b>Grip</b> — grab &amp; move<br>
        <b>Trigger</b> — rotate<br>
        <b>Thumbstick ↑↓</b> — scale<br>
        <b>B / Y</b> — remove model<br>
        <br>
        White ray = ready<br>
        Red ray = active<br>
        <br>
        <b>MR mode:</b> models float<br>
        in your real room.
      </div>
    </div>
    <div class="sidebar-section" style="flex:1">
      <div class="sidebar-title">File Format Tips</div>
      <div class="hint">
        Packed .mpd files load<br>fully self-contained.<br><br>
        Plain .ldr files need<br>sub-parts fetched from<br>the LDraw CDN — requires<br>internet access.
      </div>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
    "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.4/src/index.js"
  }
}
</script>

<!-- Fuse.js for fuzzy search -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/7.0.0/fuse.min.js"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }            from 'three/addons/controls/OrbitControls.js';
import { LDrawLoader }              from 'three/addons/loaders/LDrawLoader.js';
import { RoomEnvironment }          from 'three/addons/environments/RoomEnvironment.js';

import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';

// Patch Three.js prototypes once — every Mesh and BufferGeometry in the scene
// automatically gets BVH-accelerated raycasting after this point.
THREE.BufferGeometry.prototype.computeBoundsTree  = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree  = disposeBoundsTree;
THREE.Mesh.prototype.raycast                      = acceleratedRaycast;


// ─── §1  Config ───────────────────────────────────────────────────────────────

const BASE_REPO   = 'anteloc/ldraw-lib';
const REPO_BRANCH = 'master';
const PARTS_CDN    = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/ldraw/`;
const DEMO_MODEL   = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models/8419-1.1.mpd`;
const MODELS_INDEX = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models-index.jsonl`;
const RAW_BASE     = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models/`;

// XR scene hierarchy constants
// LDU → metres: 1 LDU = 0.4 mm = 0.0004 m, ×2.5 = hand-held / table-top scale
const LDU_TO_METERS = 0.0004 * 2.5;
const MAX_MODELS    = 5;
const MODEL_SPACING = 0.35;   // metres between model pivots in XR
const MODEL_PIVOT_Y = 0.9;    // metres above floor
const MODEL_PIVOT_Z = -0.6;   // metres in front of user

// XR controller / laser constants
const LASER_LENGTH          = 5;      // metres
const LASER_RADIUS          = 0.003;  // metres — visible thickness in VR
const COLOR_IDLE            = 0xffffff;
const COLOR_GRABBED         = 0xff2222;
const ROTATE_SENSITIVITY    = 10.0;   // rotation speed multiplier
const SCALE_SPEED           = 0.02;   // scale change per frame at full thumbstick deflection
// Raycasting throttle: when no gesture is active, only raycast every N frames.
// At 72fps, N=3 gives ~24 laser updates/sec — imperceptible for idle aiming.
// Active gestures always raycast every frame for precision.
const RAYCAST_IDLE_INTERVAL = 3;

// Browser interaction constants
const NUDGE_STEP = 100;   // LDU — about 4 cm at 1:1 scale

// Model browser
const MAX_RESULTS = 50;

// Scene background colour — saved here so onXRSessionEnd can restore it
const BROWSER_BG = new THREE.Color(0x0e0e10);


// ─── §2  Renderer + Scene ─────────────────────────────────────────────────────

const container = document.getElementById('canvas-container');

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;    // PCFSoft is overkill; PCF is a good balance
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = BROWSER_BG;

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;


// ─── §3  Scene objects — lights, grid, ground, MR shadow disc ────────────────

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
dirLight.position.set(500, 1000, 500);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(1024, 1024);
Object.assign(dirLight.shadow.camera, { near: 1, far: 10000, left: -2000, right: 2000, top: 2000, bottom: -2000 });
scene.add(dirLight);

// Grid & shadow ground — browser / VR only, hidden in MR
const gridHelper = new THREE.GridHelper(4000, 50, 0x333344, 0x222230);
scene.add(gridHelper);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(10000, 10000),
  new THREE.ShadowMaterial({ opacity: 0.2 })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// MR shadow disc — subtle circle anchoring the model to the real-world surface.
// Replaces the grid in MR mode where an opaque floor plane is inappropriate.
const mrShadowDisc = new THREE.Mesh(
  new THREE.CircleGeometry(0.18, 64),
  new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25, depthWrite: false })
);
mrShadowDisc.rotation.x = -Math.PI / 2;
mrShadowDisc.visible = false; // shown only in MR
scene.add(mrShadowDisc);


// ─── §4  Camera + OrbitControls ───────────────────────────────────────────────

const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 50000);
camera.position.set(0, 400, 1200);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

function resize() {
  const w = container.clientWidth, h = container.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
resize();
window.addEventListener('resize', resize);


// ─── §5  Model registry ───────────────────────────────────────────────────────
//
// Each loaded model lives in a ModelEntry:
//
//   scene
//     ├── (browser) entry.mesh   ← normal scale, LDU units
//     └── entry.pivot            ← world position of model in XR
//           └── entry.root       ← uniform scale (LDU→metres) + rotation
//                 └── (XR) entry.mesh
//
// The pivot/root wrapper is always in the scene; the mesh is reparented
// between scene root (browser) and root (XR) on session start/end.

const models = [];   // all currently loaded models, in load order
const _meshList = []; // cached models.map(e => e.mesh) — updated on load/remove

let edgesVisible  = true;
let selectedEntry = null;   // model currently selected for keyboard nudge

function createEntry(mesh, name) {
  // Place new XR pivot to the right of all existing ones
  const pivotX = models.reduce((maxX, e) => Math.max(maxX, e.pivot.position.x), 0)
    + (models.length > 0 ? MODEL_SPACING : 0);

  const pivot = new THREE.Group();
  pivot.position.set(pivotX, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
  scene.add(pivot);

  const root = new THREE.Group();
  root.scale.setScalar(LDU_TO_METERS);
  pivot.add(root);

  return { mesh, pivot, root, name };
}

function fitCamera() {
  if (models.length === 0) {
    camera.position.set(0, 400, 1200);
    controls.target.set(0, 0, 0);
    controls.update();
    return;
  }
  const box = new THREE.Box3();
  for (const entry of models) box.expandByObject(entry.mesh);
  const size   = box.getSize(new THREE.Vector3());
  const centre = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const dist   = (maxDim / (2 * Math.tan(camera.fov * Math.PI / 360))) * 1.6;
  controls.target.copy(centre);
  camera.position.set(centre.x + dist * 0.3, centre.y + dist * 0.4, centre.z + dist);
  controls.update();
  gridHelper.position.y = box.min.y;
  ground.position.y     = box.min.y;
}

function renderModelList() {
  sceneCountEl.textContent = models.length === 0
    ? 'No models loaded'
    : `${models.length} / ${MAX_MODELS} model${models.length > 1 ? 's' : ''}`;

  sceneModelListEl.innerHTML = models.length === 0
    ? '<span class="model-list-empty">—</span>'
    : models.map((entry, i) =>
        `<div class="model-list-item${entry === selectedEntry ? ' selected' : ''}">` +
          `<span class="model-list-name" title="${escHtml(entry.name)}">${escHtml(entry.name)}</span>` +
          `<button class="model-list-remove" data-idx="${i}" title="Remove from scene">✕</button>` +
        `</div>`
      ).join('');
}

function disposeMesh(mesh) {
  mesh.traverse(o => {
    if (o.geometry) { o.geometry.disposeBoundsTree?.(); o.geometry.dispose(); }
    if (o.material) (Array.isArray(o.material) ? o.material : [o.material]).forEach(m => m.dispose());
  });
}

function removeEntry(entry) {
  // Release any XR slot targeting this entry
  for (const slot of slots) {
    if (slot.grab.entry === entry || slot.rotate.entry === entry) endInteraction(slot);
  }
  if (selectedEntry === entry) selectedEntry = null;

  const { mesh, pivot, root } = entry;
  root.remove(mesh);
  scene.remove(mesh);
  scene.remove(pivot);
  disposeMesh(mesh);

  models.splice(models.indexOf(entry), 1);
  _meshList.splice(_meshList.indexOf(entry.mesh), 1);
  renderModelList();

  if (models.length === 0) {
    dropZone.style.display = '';
    setStatus('No model loaded');
  } else {
    fitCamera();
  }
}

function clearAllModels() {
  for (const entry of models.slice()) removeEntry(entry); // slice — don't mutate while iterating
}


// ─── §6  Model loading ────────────────────────────────────────────────────────
//
// makeLDrawLoader — constructs and primes a loader in one await.
//   preloadMaterials failure is swallowed; the loader still resolves
//   colours correctly for packed .mpd files without it.
//
// loadModelFromURL  — resolves with the model group (throws on error).
// loadModelFromText — synchronous: parse() returns the group directly.
//
// Both call onModelLoaded on success; errors are surfaced via showError.

function onProgress(xhr) {
  if (xhr.total) loadingSub.textContent = 'Downloading… ' + Math.round(xhr.loaded / xhr.total * 100) + '%';
}

async function makeLDrawLoader() {
  const loader = new LDrawLoader();
  loader.setPartsLibraryPath(PARTS_CDN);
  await loader.preloadMaterials(PARTS_CDN + 'LDConfig.ldr').catch(() => {});
  return loader;
}

async function loadModelFromURL(url, name, errorMsg) {
  try {
    const loader = await makeLDrawLoader();
    const model  = await loader.loadAsync(url, onProgress);
    onModelLoaded(model, name);
  } catch (err) {
    showError(errorMsg + '\n\n' + err);
  }
}

async function loadModelFromText(text, name) {
  try {
    const loader = await makeLDrawLoader();
    const model  = loader.parse(text);   // synchronous — returns group directly
    onModelLoaded(model, name);
  } catch (err) {
    console.error(err);
    showError('Parse error: ' + (err?.message || String(err)) +
      '\n\nPacked .mpd files work best — all sub-parts are bundled inside.');
  }
}

function onModelLoaded(model, filename) {
  if (models.length >= MAX_MODELS) {
    showError(`Maximum ${MAX_MODELS} models in scene. Remove one first.`);
    return;
  }

  errorBanner.classList.remove('visible');
  model.rotation.x = Math.PI; // LDraw Y-down → Y-up
  model.traverse(o => {
    if (o.isMesh) {
      o.castShadow = true;
      o.receiveShadow = true;
      o.geometry.computeBoundsTree();   // BVH — O(log n) raycasts
    } else if (o.isLineSegments) {
      o.raycast = () => {};             // edges are visual only — never raycasted
    }
  });

  scene.add(model);
  const entry = createEntry(model, filename);
  models.push(entry);
  _meshList.push(model);

  // In browser mode, separate models along X so they don't stack on top of each other.
  // Compute the right edge of all existing models and place the new one just past it.
  if (models.length > 1) {
    const existingBox = new THREE.Box3();
    for (const e of models.slice(0, -1)) existingBox.expandByObject(e.mesh);
    const newBox  = new THREE.Box3().setFromObject(model);
    const newSize = newBox.getSize(new THREE.Vector3());
    const gap     = newSize.x * 0.2;   // 20% of own width as breathing room
    model.position.x = existingBox.max.x + gap + newSize.x / 2 - newBox.getCenter(new THREE.Vector3()).x;
  }

  if (models.length === 1) dropZone.style.display = 'none';
  fitCamera();
  renderModelList();
  hideLoading();
  setStatus(`Loaded: ${filename} (${models.length}/${MAX_MODELS} in scene)`);
}

function loadFile(file) {
  if (!file) return;
  showLoading('Reading file…', file.name);
  const reader = new FileReader();
  reader.onload = e => {
    showLoading('Parsing model…', 'Sub-parts resolved from LDraw CDN — needs internet');
    loadModelFromText(e.target.result, file.name);
  };
  reader.onerror = () => showError('Could not read file.');
  reader.readAsText(file);
}

function loadFromURL() {
  const url = document.getElementById('url-input').value.trim();
  if (!url) return;
  showLoading('Fetching…', url);
  loadModelFromURL(url, url.split('/').pop(), 'Could not load URL — CORS may be blocking it.\nTry downloading and opening locally.');
}


// ─── §7  Browser interaction — drag, select, focus, nudge ────────────────────
//
// Right-click drag on a model → move it in X/Z on its own ground plane.
// Left-click on a model       → select it (arrow keys nudge it).
// Right-click on empty space  → falls through to OrbitControls pan.
// Quest 3 browser: click-and-hold (150 ms) triggers drag same as right-drag.

// Reusable temporaries — never allocated per event
const _browserRay = new THREE.Raycaster();
const _dragPlane  = new THREE.Plane();
const _dragOffset = new THREE.Vector3();
const _planeHit   = new THREE.Vector3();
const _ndcVec     = new THREE.Vector2();

let _dragEntry      = null;   // entry currently being dragged
let _dragActive     = false;
let _holdTimer      = null;   // for Quest-style click-and-hold
let _pointerDownPos = null;   // { x, y } at pointerdown

// Sets _browserRay from a DOM client-space coordinate.
// Centralises the NDC conversion used by raycast, drag-start, and drag-move.
function setRayFromClient(clientX, clientY) {
  const rect = renderer.domElement.getBoundingClientRect();
  _ndcVec.set(
    ((clientX - rect.left)  / rect.width)  * 2 - 1,
    -((clientY - rect.top) / rect.height) * 2 + 1
  );
  _browserRay.setFromCamera(_ndcVec, camera);
}

function browserRaycast(clientX, clientY) {
  setRayFromClient(clientX, clientY);
  const hits = _browserRay.intersectObjects(_meshList, true);
  return hits.length > 0 ? hits[0] : null;
}

function hitToEntry(hit) {
  // Each entry's mesh is the root of the loaded model — if the hit object
  // lives anywhere inside it, getObjectById will find it in one call.
  return models.find(e => e.mesh.getObjectById(hit.object.id)) ?? null;
}

function selectEntry(entry) {
  selectedEntry = entry;
  renderModelList();
}

function startDrag(entry, clientX, clientY) {
  _dragEntry  = entry;
  _dragActive = true;
  controls.enabled = false;
  container.classList.add('drag-active');
  container.classList.remove('drag-ready');

  // Build a horizontal plane at the model's current Y
  _dragPlane.set(new THREE.Vector3(0, 1, 0), -entry.mesh.position.y);

  // Record offset from plane hit to model origin so it doesn't snap to cursor
  setRayFromClient(clientX, clientY);
  _browserRay.ray.intersectPlane(_dragPlane, _planeHit);
  _dragOffset.set(entry.mesh.position.x - _planeHit.x, 0, entry.mesh.position.z - _planeHit.z);
}

function moveDrag(clientX, clientY) {
  if (!_dragActive || !_dragEntry) return;
  setRayFromClient(clientX, clientY);
  if (_browserRay.ray.intersectPlane(_dragPlane, _planeHit)) {
    _dragEntry.mesh.position.x = _planeHit.x + _dragOffset.x;
    _dragEntry.mesh.position.z = _planeHit.z + _dragOffset.z;
  }
}

function endDrag() {
  if (_holdTimer) { clearTimeout(_holdTimer); _holdTimer = null; }
  if (!_dragActive) return;
  _dragActive = false;
  _dragEntry  = null;
  controls.enabled = true;
  container.classList.remove('drag-active');
}

function resetView() {
  if (renderer.xr.isPresenting) {
    let x = 0;
    for (const entry of models) {
      entry.root.scale.setScalar(LDU_TO_METERS);
      entry.root.rotation.set(0, 0, 0);
      entry.pivot.position.set(x, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
      x += MODEL_SPACING;
    }
    mrShadowDisc.position.set(0, 0.02, MODEL_PIVOT_Z);
    mrShadowDisc.scale.setScalar(1);
  } else {
    fitCamera();
  }
}

function toggleEdges() {
  edgesVisible = !edgesVisible;
  document.getElementById('toggle-edges').classList.toggle('on', edgesVisible);
  for (const entry of models) {
    entry.mesh.traverse(o => { if (o.isLineSegments) o.visible = edgesVisible; });
  }
}

function toggleGrid() {
  const on = !gridHelper.visible;
  gridHelper.visible = on;
  document.getElementById('toggle-grid').classList.toggle('on', on);
}


// ─── §8  XR controllers — lasers, slots, per-frame interaction ────────────────
//
// Three.js exposes two separate tracked spaces per physical controller:
//   getController(i)     → pointer / target-ray space  (laser origin)
//   getControllerGrip(i) → grip space                  (where the hand holds it)
//
// The controller model from XRControllerModelFactory must be attached to the
// grip space; the laser must be attached to the pointer space.
// Both are added to the scene and their poses are updated automatically by the
// XR runtime each frame — no manual position/quaternion sync needed.
//
// Each physical controller has its own independent interaction slot so both
// hands can interact with different models simultaneously.
//
// slot.type      — null | 'grab' | 'rotate'
// slot.grab      — grab state, valid while type === 'grab'
// slot.rotate    — rotate state, valid while type === 'rotate'
//
// Cross-controller rule: two grabs on the *same* model are denied — they would
// fight each other. Any other combination is allowed.

const controllerModelFactory = new XRControllerModelFactory();

// Reusable temporaries — never allocated per-frame
const _ctrlWorldPos  = new THREE.Vector3();
const _ctrlWorldQuat = new THREE.Quaternion();
const _ctrlWorldQInv = new THREE.Quaternion();
const _raycaster     = new THREE.Raycaster();
_raycaster.firstHitOnly = true;   // BVH short-circuits after first hit — much faster
const _rayOrigin     = new THREE.Vector3();
const _rayDir        = new THREE.Vector3();
const _fingerDelta   = new THREE.Vector3();
const _oldArm        = new THREE.Vector3();
const _newArm        = new THREE.Vector3();
const _rotQuat       = new THREE.Quaternion();

let _frameCount = 0;

// ── Laser — cylinder beam + tip ring ──────────────────────────────────────────
//
// A CylinderGeometry is used instead of Line because WebGL does not support
// line widths > 1px on most drivers, making Line invisible at VR scale.
// The cylinder is oriented along –Z (the pointer forward direction).

function makeLaser() {
  const group = new THREE.Group();

  // Beam — thin cylinder from origin to LASER_LENGTH along –Z
  const beamMat = new THREE.MeshBasicMaterial({ color: COLOR_IDLE, transparent: true, opacity: 0.6 });
  const beam = new THREE.Mesh(new THREE.CylinderGeometry(LASER_RADIUS, LASER_RADIUS, LASER_LENGTH, 8), beamMat);
  // CylinderGeometry stands along Y; rotate and translate so it lies along –Z
  beam.rotation.x = Math.PI / 2;
  beam.position.z = -LASER_LENGTH / 2;
  group.add(beam);

  // Tip ring — faces along the ray axis (perpendicular to –Z)
  const ringMat = new THREE.MeshBasicMaterial({ color: COLOR_IDLE, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
  const ring = new THREE.Mesh(new THREE.RingGeometry(0.006, 0.012, 32), ringMat);
  ring.position.z = -LASER_LENGTH;
  group.add(ring);

  return group;
}

function setLaserColor(pointer, color) {
  const laser = pointer.children[0];
  laser.children[0].material.color.setHex(color);  // beam
  laser.children[1].material.color.setHex(color);  // ring
}

// Called every frame for each controller. Casts a ray against all loaded
// models, scales the beam and repositions the tip ring to the hit point
// (or restores full length on a miss). Returns { hitPoint, hitEntry }.
function updateLaser(pointer) {
  const beam = pointer.children[0].children[0];
  const ring = pointer.children[0].children[1];
  const resetBeam = () => { beam.scale.z = 1; ring.position.z = -LASER_LENGTH; };

  if (models.length === 0) return resetBeam() || { hitPoint: null, hitEntry: null };

  pointer.getWorldPosition(_rayOrigin);
  _rayDir.set(0, 0, -1).transformDirection(pointer.matrixWorld);
  _raycaster.set(_rayOrigin, _rayDir);

  // Test all loaded meshes; pick the nearest hit across all of them
  let nearestDist  = Infinity;
  let nearestPoint = null;
  let nearestEntry = null;

  for (const entry of models) {
    const hits = _raycaster.intersectObject(entry.mesh, /* recursive */ true);
    if (hits.length > 0 && hits[0].distance < nearestDist) {
      nearestDist  = hits[0].distance;
      nearestPoint = hits[0].point;
      nearestEntry = entry;
    }
  }

  if (nearestEntry === null) return resetBeam() || { hitPoint: null, hitEntry: null };

  beam.scale.z = nearestDist / LASER_LENGTH;
  ring.position.z = -nearestDist;
  return { hitPoint: nearestPoint, hitEntry: nearestEntry };
}

// ── Interaction slots ──────────────────────────────────────────────────────────

function makeSlot() {
  return {
    type:    null,
    pointer: null,
    grab: {
      entry:      null,
      offsetPos:  new THREE.Vector3(),
      offsetQuat: new THREE.Quaternion(),
    },
    rotate: {
      entry:           null,
      touchPointLocal: new THREE.Vector3(),
      prevFingerPos:   new THREE.Vector3(),
    },
  };
}

const slots = [makeSlot(), makeSlot()];

function otherSlot(slot) {
  return slots[1 - slots.indexOf(slot)];
}

function startGrab(slot, pointer, hitPoint, hitEntry) {
  // Deny if the other hand is already grabbing the same model
  const other = otherSlot(slot);
  if (other.type === 'grab' && other.grab.entry === hitEntry) return;

  const { pivot, root } = hitEntry;
  pointer.getWorldPosition(_ctrlWorldPos);
  pointer.getWorldQuaternion(_ctrlWorldQuat);
  _ctrlWorldQInv.copy(_ctrlWorldQuat).invert();

  slot.grab.entry = hitEntry;
  slot.grab.offsetPos
    .copy(pivot.position)
    .sub(_ctrlWorldPos)
    .applyQuaternion(_ctrlWorldQInv);
  slot.grab.offsetQuat
    .multiplyQuaternions(_ctrlWorldQInv, root.getWorldQuaternion(new THREE.Quaternion()));

  slot.type    = 'grab';
  slot.pointer = pointer;
  setLaserColor(pointer, COLOR_GRABBED);
}

function startRotate(slot, pointer, hitPoint, hitEntry) {
  slot.rotate.entry = hitEntry;
  hitEntry.root.worldToLocal(slot.rotate.touchPointLocal.copy(hitPoint));
  pointer.getWorldPosition(slot.rotate.prevFingerPos);

  slot.type    = 'rotate';
  slot.pointer = pointer;
  setLaserColor(pointer, COLOR_GRABBED);
}

function endInteraction(slot) {
  if (!slot.type) return;
  if (slot.pointer) setLaserColor(slot.pointer, COLOR_IDLE);
  slot.type         = null;
  slot.pointer      = null;
  slot.grab.entry   = null;
  slot.rotate.entry = null;
}

function applyGrab(slot) {
  const { pivot, root } = slot.grab.entry;
  const ctrl = slot.pointer;
  ctrl.getWorldPosition(_ctrlWorldPos);
  ctrl.getWorldQuaternion(_ctrlWorldQuat);

  pivot.position
    .copy(slot.grab.offsetPos)
    .applyQuaternion(_ctrlWorldQuat)
    .add(_ctrlWorldPos);

  root.quaternion.multiplyQuaternions(_ctrlWorldQuat, slot.grab.offsetQuat);

  mrShadowDisc.position.x = pivot.position.x;
  mrShadowDisc.position.z = pivot.position.z;
}

function applyRotate(slot) {
  const ctrl = slot.pointer;

  // Finger lifted — ray no longer on this model, pause rotation
  if (ctrl.userData.hitEntry !== slot.rotate.entry) {
    ctrl.getWorldPosition(slot.rotate.prevFingerPos);
    return;
  }

  ctrl.getWorldPosition(_ctrlWorldPos);
  _fingerDelta.subVectors(_ctrlWorldPos, slot.rotate.prevFingerPos);

  if (_fingerDelta.lengthSq() > 0) {
    const { root } = slot.rotate.entry;

    root.getWorldPosition(_newArm);                 // centroid
    _oldArm.copy(slot.rotate.touchPointLocal)
      .applyMatrix4(root.matrixWorld)
      .sub(_newArm);                                // arm: centroid → touch point

    _newArm.copy(_oldArm).addScaledVector(_fingerDelta, ROTATE_SENSITIVITY);
    _newArm.setLength(_oldArm.length());

    _rotQuat.setFromUnitVectors(_oldArm.normalize(), _newArm.normalize());
    root.quaternion.premultiply(_rotQuat);
  }

  slot.rotate.prevFingerPos.copy(_ctrlWorldPos);
}

// Called every frame while XR is presenting
function updateXRControls() {
  _frameCount++;

  // 1. Update laser visuals — throttled when idle, every frame when active.
  //    Active = at least one slot has an ongoing gesture.
  const anyActive = slots.some(s => s.type !== null);
  const doRaycast = anyActive || (_frameCount % RAYCAST_IDLE_INTERVAL === 0);

  if (doRaycast) {
    for (const { pointer } of controllers) {
      ({ hitPoint: pointer.userData.hitPoint,
         hitEntry: pointer.userData.hitEntry } = updateLaser(pointer));
    }
  }

  // 2. Apply both interaction slots independently
  for (const slot of slots) {
    if (slot.type === 'grab')   applyGrab(slot);
    if (slot.type === 'rotate') applyRotate(slot);
  }

  // 3. Thumbstick scaling — active on any controller whose laser hits a model
  for (const { pointer } of controllers) {
    const entry = pointer.userData.hitEntry;
    if (!entry) continue;

    const source = pointer.userData.xrInputSource;
    if (!source?.gamepad) continue;

    const thumbY = source.gamepad.axes[3] ?? 0;
    if (Math.abs(thumbY) <= 0.1) continue;

    const newScale = THREE.MathUtils.clamp(
      entry.root.scale.x * (1 + thumbY * SCALE_SPEED),
      LDU_TO_METERS * 0.05,
      LDU_TO_METERS * 30
    );
    entry.root.scale.setScalar(newScale);
    mrShadowDisc.scale.setScalar(newScale / LDU_TO_METERS);
  }

  // 4. B/Y button — remove the model the laser is currently hitting.
  //    Rising-edge detection fires exactly once per press.
  for (const { pointer } of controllers) {
    const source     = pointer.userData.xrInputSource;
    const pressed    = source?.gamepad?.buttons[5]?.pressed ?? false;
    const wasPressed = pointer.userData.prevBYPressed ?? false;
    pointer.userData.prevBYPressed = pressed;

    if (pressed && !wasPressed) {
      const entry = pointer.userData.hitEntry;
      if (entry) removeEntry(entry);
    }
  }
}

// ── Build both controllers ─────────────────────────────────────────────────────

function buildController(index) {
  // Pointer space — laser lives here
  const pointer = renderer.xr.getController(index);
  pointer.add(makeLaser());
  scene.add(pointer);

  // Grip space — hardware model lives here
  const grip = renderer.xr.getControllerGrip(index);
  grip.add(controllerModelFactory.createControllerModel(grip));
  scene.add(grip);

  return { pointer, grip };
}

const controllers = [buildController(0), buildController(1)];

// Wire gesture events on both controllers
for (let i = 0; i < controllers.length; i++) {
  const { pointer } = controllers[i];
  const slot = slots[i];

  pointer.addEventListener('connected',    e => { pointer.userData.xrInputSource = e.data; });
  pointer.addEventListener('disconnected', () => { pointer.userData.xrInputSource = null; });

  pointer.addEventListener('squeezestart', () => {
    if (slot.type) return;
    const { hitPoint, hitEntry } = pointer.userData;
    if (!hitEntry) return;
    startGrab(slot, pointer, hitPoint, hitEntry);
  });
  pointer.addEventListener('squeezeend', () => {
    if (slot.type === 'grab') endInteraction(slot);
  });

  pointer.addEventListener('selectstart', () => {
    if (slot.type) return;
    const { hitPoint, hitEntry } = pointer.userData;
    if (!hitEntry) return;
    startRotate(slot, pointer, hitPoint, hitEntry);
  });
  pointer.addEventListener('selectend', () => {
    if (slot.type === 'rotate') endInteraction(slot);
  });
}


// ─── §9  XR session lifecycle — mode tracking, VR/MR buttons ─────────────────
//
// currentMode: 'browser' | 'vr' | 'mr'
//
// Both buttons manage their own session lifecycle manually so onXRSessionStart
// can be called directly with the correct mode — no side-channel flag needed.

let currentMode = 'browser';

const modeBadge   = document.getElementById('mode-badge');
const controlsBar = document.querySelector('.controls');

function setMode(mode) {
  currentMode = mode;
  modeBadge.className = '';
  if (mode === 'vr') { modeBadge.className = 'vr'; modeBadge.textContent = '● VR'; }
  if (mode === 'mr') { modeBadge.className = 'mr'; modeBadge.textContent = '● MR'; }
}

function onXRSessionStart(mode) {
  setMode(mode);

  // ── Flush OrbitControls damping before handing camera to XR ──────────────
  // Even with controls.enabled = false, controls.update() with dampingFactor
  // > 0 keeps applying residual momentum to camera.position every frame.
  // Drain that momentum NOW before the XR runtime takes ownership of the
  // camera, so there is zero leftover delta fighting the head-pose tracker.
  controls.saveState();           // snapshot so we can restore on session end
  controls.dampingFactor = 0;     // kill damping temporarily
  controls.update();              // one tick to flush pending delta to zero
  controls.dampingFactor = 0.06;  // restore (won't run again until session ends)
  controls.enabled = false;       // disable input handling

  gridHelper.visible = false;
  ground.visible = false;
  dirLight.castShadow = false;   // shadows off in XR — saves a full shadow map render every frame

  if (mode === 'mr') {
    // Transparent background → passthrough shows through
    scene.background = null;
    renderer.setClearColor(0x000000, 0);
    // Boost ambient slightly so model isn't too dark against bright room
    ambientLight.intensity = 1.2;
    mrShadowDisc.visible = true;
  } else {
    // VR: solid opaque black — gives the XR compositor a proper opaque layer.
    // null/transparent in VR causes the compositor to blend against undefined
    // content, contributing to silhouette-edge flicker.
    scene.background = new THREE.Color(0x000000);
    renderer.setClearColor(0x000000, 1);
    ambientLight.intensity = 0.6;
    mrShadowDisc.visible = false;
  }

  for (const entry of models) {
    const { mesh, pivot, root } = entry;
    scene.remove(mesh);
    root.add(mesh);
    // Re-centre so rotation pivots around model centre
    const box = new THREE.Box3().setFromObject(mesh);
    const centre = box.getCenter(new THREE.Vector3());
    mesh.position.sub(centre);
  }

  // Place pivots using the XR reference space viewer pose so we get the actual
  // floor-relative eye height, then position models just below eye level.
  // We poll every frame until the viewer pose is available (usually frame 1-2).
  const placePivots = () => {
    const frame    = renderer.xr.getFrame();
    const refSpace = renderer.xr.getReferenceSpace();
    if (!frame || !refSpace) { requestAnimationFrame(placePivots); return; }

    const pose = frame.getViewerPose(refSpace);
    if (!pose) { requestAnimationFrame(placePivots); return; }

    // local-floor gives Y=0 at floor. Place models at comfortable table height.
    let x = 0;
    for (const entry of models) {
      entry.pivot.position.set(x, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
      x += MODEL_SPACING;
    }
    if (mode === 'mr') mrShadowDisc.position.set(0, 0.02, MODEL_PIVOT_Z);
  };
  requestAnimationFrame(placePivots);
}

function onXRSessionEnd() {
  setMode('browser');

  // Drop all active interactions and reset laser colors
  for (const slot of slots) endInteraction(slot);
  for (const { pointer } of controllers) {
    setLaserColor(pointer, COLOR_IDLE);
    pointer.userData.hitPoint      = null;
    pointer.userData.hitEntry      = null;
    pointer.userData.xrInputSource = null;
    pointer.userData.prevBYPressed = false;
  }

  // Restore OrbitControls to the exact state they were in before XR started
  controls.reset();       // returns to saveState() snapshot
  controls.enabled = true;

  // Restore browser visuals
  scene.background = BROWSER_BG;
  renderer.setClearColor(0x000000, 1);
  ambientLight.intensity = 0.6;
  gridHelper.visible = document.getElementById('toggle-grid').classList.contains('on');
  ground.visible = true;
  dirLight.castShadow = true;
  mrShadowDisc.visible = false;

  // Return all models to scene root
  for (const entry of models) {
    const { mesh, pivot, root } = entry;
    root.remove(mesh);
    mesh.position.set(0, 0, 0);
    scene.add(mesh);
    // Reset XR transforms for next session
    root.scale.setScalar(LDU_TO_METERS);
    root.rotation.set(0, 0, 0);
  }
  if (models.length > 0) fitCamera();
}

renderer.xr.addEventListener('sessionend', onXRSessionEnd);

// ── Shared session-request options ────────────────────────────────────────────
const XR_SESSION_OPTS = {
  requiredFeatures: ['local-floor'],
  optionalFeatures: ['bounded-floor', 'hand-tracking'],
};

// ── VR button ─────────────────────────────────────────────────────────────────

function makeXRButton(label, className) {
  const btn = document.createElement('button');
  btn.className = className;
  btn.textContent = label;
  btn.disabled = true;
  return btn;
}

const vrButton = makeXRButton('ENTER VR', 'btn xr-btn');

if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-vr').then(supported => {
    vrButton.disabled = !supported;
    vrButton.textContent = supported ? 'ENTER VR' : 'VR NOT SUPPORTED';
  }).catch(() => { vrButton.disabled = true; vrButton.textContent = 'VR NOT SUPPORTED'; });

  let vrSession = null;
  vrButton.addEventListener('click', () => {
    if (vrSession === null) {
      navigator.xr.requestSession('immersive-vr', XR_SESSION_OPTS)
        .then(session => {
          renderer.xr.setSession(session);
          onXRSessionStart('vr');
          vrSession = session;
          vrButton.textContent = 'EXIT VR';
          session.addEventListener('end', () => {
            vrSession = null;
            vrButton.textContent = 'ENTER VR';
          });
        }).catch(err => console.error('VR session request failed:', err));
    } else {
      vrSession.end();
    }
  });
} else {
  vrButton.textContent = 'VR NOT SUPPORTED';
}

controlsBar.prepend(vrButton);

// ── MR button ─────────────────────────────────────────────────────────────────

const mrButton = makeXRButton('ENTER MR', 'btn xr-btn-mr');

if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-ar').then(supported => {
    mrButton.disabled = !supported;
    mrButton.textContent = supported ? 'ENTER MR' : 'MR NOT SUPPORTED';
  }).catch(() => { mrButton.disabled = true; mrButton.textContent = 'MR NOT SUPPORTED'; });

  let mrSession = null;
  mrButton.addEventListener('click', () => {
    if (mrSession === null) {
      navigator.xr.requestSession('immersive-ar', XR_SESSION_OPTS)
        .then(session => {
          renderer.xr.setSession(session);
          onXRSessionStart('mr');
          mrSession = session;
          mrButton.textContent = 'EXIT MR';
          session.addEventListener('end', () => {
            mrSession = null;
            mrButton.textContent = 'ENTER MR';
          });
        }).catch(err => console.error('MR session request failed:', err));
    } else {
      mrSession.end();
    }
  });
} else {
  mrButton.textContent = 'MR NOT SUPPORTED';
}

vrButton.insertAdjacentElement('afterend', mrButton);

// ── Animation loop ────────────────────────────────────────────────────────────
// IMPORTANT: controls.update() must NOT run while XR is presenting.
// The XR runtime owns the camera pose during a session. If OrbitControls
// also runs update() every frame — even with enabled=false, the damping
// momentum still nudges camera.position — it fights the XR pose tracker
// and produces the rapid head-movement jitter.
renderer.setAnimationLoop((timestamp, frame) => {
  if (renderer.xr.isPresenting && frame) {
    updateXRControls();
  } else {
    controls.update(); // only touch the camera in browser mode
  }
  renderer.render(scene, camera);
});


// ─── §10  Model browser ───────────────────────────────────────────────────────
//
// The index is a JSONL file — one JSON object per line:
//   {"name":"filename.mpd","search_key":"Human Readable Name"}
//
// Fuse.js searches both search_key (primary) and name (fallback).
// Results are capped at MAX_RESULTS for rendering performance.

let mbModels  = [];   // [{ name, search_key, url }]
let mbFuse    = null; // Fuse instance, built after model list loads
let mbFocused = -1;   // keyboard-nav index into current result list

const mbOverlay   = document.getElementById('model-browser');
const mbSearchEl  = document.getElementById('mb-search-input');
const mbResultsEl = document.getElementById('mb-results');
const mbStatusEl  = document.getElementById('mb-status');

async function fetchModelList() {
  try {
    const res = await fetch(MODELS_INDEX);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();

    mbModels = text
      .split('\n')
      .filter(line => line.trim())
      .map(line => {
        const { name, search_key } = JSON.parse(line);
        return { name, search_key, url: RAW_BASE + encodeURIComponent(name) };
      });

    mbFuse = new Fuse(mbModels, {
      keys: [
        { name: 'search_key', weight: 2 },  // human label — higher weight
        { name: 'name',       weight: 1 },  // filename — fallback
      ],
      threshold:          0.35,
      distance:           200,
      minMatchCharLength: 2,
      includeScore:       true,
      includeMatches:     true,
    });

    mbStatusEl.textContent = mbModels.length + ' models available — type to search';
    mbResultsEl.innerHTML  = '';
  } catch (err) {
    mbStatusEl.textContent = 'Could not load model list — check internet connection';
    mbResultsEl.innerHTML  = '<div class="mb-empty">Index unavailable.<br>Try the URL loader instead.</div>';
    console.warn('Model list fetch failed:', err);
  }
}
fetchModelList();

function openModelBrowser() {
  if (renderer.xr.isPresenting) return;
  mbOverlay.classList.add('open');
  mbSearchEl.value = '';
  mbFocused = -1;
  renderResults([]);
  mbStatusEl.textContent = mbModels.length
    ? mbModels.length + ' models available — type to search'
    : 'Loading model list…';
  requestAnimationFrame(() => mbSearchEl.focus());
}

function closeModelBrowser() {
  mbOverlay.classList.remove('open');
}

function loadFromBrowser(url, name) {
  closeModelBrowser();
  showLoading('Loading model…', name);
  loadModelFromURL(url, name, 'Could not load model.');
}

function escHtml(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function highlightField(text, matches, key) {
  if (!text) return '';
  if (!matches || !matches.length) return escHtml(text);

  const marked = new Set();
  for (const m of matches) {
    if (m.key === key) {
      for (const [start, end] of m.indices) {
        for (let i = start; i <= end; i++) marked.add(i);
      }
    }
  }

  if (marked.size === 0) return escHtml(text);

  let html = '', inMark = false;
  for (let i = 0; i < text.length; i++) {
    if (marked.has(i)  && !inMark) { html += '<mark>'; inMark = true; }
    if (!marked.has(i) &&  inMark) { html += '</mark>'; inMark = false; }
    html += escHtml(text[i]);
  }
  if (inMark) html += '</mark>';
  return html;
}

function renderResults(results) {
  if (results.length === 0) {
    const q = mbSearchEl.value.trim();
    mbResultsEl.innerHTML = q.length >= 2
      ? '<div class="mb-empty">No matches for "<b>' + escHtml(q) + '</b>".<br>Try a set number, part of the name,<br>or a different spelling.</div>'
      : '';
    return;
  }

  mbResultsEl.innerHTML = results.map((r, idx) => {
    const { name, search_key, url } = r.item;
    const labelHtml    = highlightField(search_key, r.matches, 'search_key');
    const filenameHtml = highlightField(name,       r.matches, 'name');
    return (
      '<div class="mb-result" data-idx="' + idx + '" data-url="' + escHtml(url) + '" data-name="' + escHtml(search_key || name) + '">' +
        '<div class="mb-result-label">' +
          '<span class="mb-result-name">'     + labelHtml    + '</span>' +
          '<span class="mb-result-filename">' + filenameHtml + '</span>' +
        '</div>' +
        '<button class="mb-load-btn">Load</button>' +
      '</div>'
    );
  }).join('');

  mbResultsEl.querySelectorAll('.mb-result').forEach(el => {
    el.addEventListener('click', () => loadFromBrowser(el.dataset.url, el.dataset.name));
    el.addEventListener('mouseenter', () => {
      mbFocused = parseInt(el.dataset.idx);
      updateFocus(mbResultsEl.querySelectorAll('.mb-result'));
    });
  });
}

function updateFocus(items) {
  items.forEach((el, i) => el.classList.toggle('focused', i === mbFocused));
  if (items[mbFocused]) items[mbFocused].scrollIntoView({ block: 'nearest' });
}


// ─── §11  UI helpers + DOM references ────────────────────────────────────────

const dropZone         = document.getElementById('drop-zone');
const loadingOverlay   = document.getElementById('loading-overlay');
const loadingMsg       = document.getElementById('loading-msg');
const loadingSub       = document.getElementById('loading-sub');
const statusEl         = document.getElementById('status');
const errorBanner      = document.getElementById('error-banner');
const errorText        = document.getElementById('error-text');
const sceneCountEl     = document.getElementById('scene-count');
const sceneModelListEl = document.getElementById('scene-model-list');

function showLoading(msg, sub) {
  loadingMsg.textContent = msg || 'Loading…';
  loadingSub.textContent = sub || '';
  loadingOverlay.classList.add('visible');
  errorBanner.classList.remove('visible');
}
function hideLoading() { loadingOverlay.classList.remove('visible'); }
function showError(msg) { hideLoading(); errorText.textContent = msg; errorBanner.classList.add('visible'); }
function setStatus(s)   { statusEl.textContent = s; }


// ─── §12  UI event wiring ─────────────────────────────────────────────────────
// All HTML→JS connections in one place; no onclick attributes in the markup.

// Header buttons
document.getElementById('btn-demo').addEventListener('click', () => {
  showLoading('Loading demo…', 'Fetching packed .mpd from GitHub');
  loadModelFromURL(DEMO_MODEL, 'car (demo)', 'Could not load demo — check your internet connection.');
});
document.getElementById('btn-browse').addEventListener('click', openModelBrowser);
document.getElementById('btn-reset-view').addEventListener('click', resetView);
document.getElementById('btn-open-file').addEventListener('click', () => document.getElementById('file-input').click());

// File input & drag-drop
document.getElementById('file-input').addEventListener('change', function() {
  if (this.files[0]) loadFile(this.files[0]);
  this.value = '';
});
container.addEventListener('dragover',  e => { e.preventDefault(); dropZone.classList.add('dragging'); });
container.addEventListener('dragleave', () => dropZone.classList.remove('dragging'));
container.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragging');
  if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
});
dropZone.addEventListener('click', () => document.getElementById('file-input').click());

// Sidebar controls
document.getElementById('btn-load-url').addEventListener('click', loadFromURL);
document.getElementById('toggle-edges').addEventListener('click', toggleEdges);
document.getElementById('toggle-grid').addEventListener('click', toggleGrid);
// Delegated remove — one listener handles all ✕ buttons in the scene model list
sceneModelListEl.addEventListener('click', e => {
  const btn = e.target.closest('.model-list-remove');
  if (btn) removeEntry(models[+btn.dataset.idx]);
});

// Error banner
document.getElementById('btn-error-close').addEventListener('click', () => errorBanner.classList.remove('visible'));

// Model browser overlay
document.getElementById('btn-mb-close').addEventListener('click', closeModelBrowser);
mbOverlay.addEventListener('click', e => { if (e.target === mbOverlay) closeModelBrowser(); });
mbSearchEl.addEventListener('input', () => {
  const q = mbSearchEl.value.trim();
  mbFocused = -1;

  if (q.length < 2) {
    renderResults([]);
    mbStatusEl.textContent = q.length === 0
      ? (mbModels.length ? mbModels.length + ' models available — type to search' : 'Loading…')
      : '1 more character needed…';
    return;
  }

  if (!mbFuse) { mbStatusEl.textContent = 'Model list not ready yet'; return; }

  const all     = mbFuse.search(q);
  const capped  = all.length > MAX_RESULTS;
  const results = capped ? all.slice(0, MAX_RESULTS) : all;

  renderResults(results);
  mbStatusEl.textContent = all.length === 0
    ? 'No matches for "' + q + '"'
    : capped
      ? `Top ${MAX_RESULTS} of ${all.length} matches for "${q}"`
      : all.length + ' match' + (all.length !== 1 ? 'es' : '') + ' for "' + q + '"';
});

// Canvas — double-click to focus orbit target on clicked point
renderer.domElement.addEventListener('dblclick', e => {
  if (models.length === 0 || renderer.xr.isPresenting) return;
  const hit = browserRaycast(e.clientX, e.clientY);
  if (hit) { controls.target.copy(hit.point); controls.update(); }
});

// Canvas — pointer events for drag, select, deselect
renderer.domElement.addEventListener('pointerdown', e => {
  if (renderer.xr.isPresenting || models.length === 0) return;
  _pointerDownPos = { x: e.clientX, y: e.clientY };

  const hit   = browserRaycast(e.clientX, e.clientY);
  const entry = hit ? hitToEntry(hit) : null;

  if (e.button === 2 && entry) {
    e.preventDefault();
    selectEntry(entry);
    startDrag(entry, e.clientX, e.clientY);
    return;
  }

  if (e.button === 0 && entry) {
    selectEntry(entry);
    container.classList.add('drag-ready');
    _holdTimer = setTimeout(() => {
      if (_pointerDownPos) startDrag(entry, _pointerDownPos.x, _pointerDownPos.y);
    }, 150);
  }
});

renderer.domElement.addEventListener('pointermove', e => {
  if (renderer.xr.isPresenting) return;
  if (_dragActive) { moveDrag(e.clientX, e.clientY); return; }
  if (models.length > 0) {
    container.classList.toggle('drag-ready', !!browserRaycast(e.clientX, e.clientY));
  }
});

renderer.domElement.addEventListener('pointerup', e => {
  if (renderer.xr.isPresenting) return;
  if (_holdTimer) { clearTimeout(_holdTimer); _holdTimer = null; }
  container.classList.remove('drag-ready');
  _pointerDownPos = null;
  if (_dragActive) { endDrag(); return; }
  if (e.button === 0) {
    const hit = browserRaycast(e.clientX, e.clientY);
    if (!hit) { selectedEntry = null; renderModelList(); }
  }
});

renderer.domElement.addEventListener('pointercancel', endDrag);
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault()); // allow right-drag

// Keyboard — nudge selected model (browser) or navigate model browser (overlay)
document.addEventListener('keydown', e => {
  // Model browser keyboard nav takes priority when open
  if (e.key === 'Escape' && mbOverlay.classList.contains('open')) {
    closeModelBrowser(); return;
  }
  if (mbOverlay.classList.contains('open')) {
    const items = mbResultsEl.querySelectorAll('.mb-result');
    if (!items.length) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      mbFocused = Math.min(mbFocused + 1, items.length - 1);
      updateFocus(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      mbFocused = Math.max(mbFocused - 1, 0);
      updateFocus(items);
    } else if (e.key === 'Enter' && mbFocused >= 0 && items[mbFocused]) {
      items[mbFocused].querySelector('.mb-load-btn').click();
    }
    return;
  }

  // Arrow-key nudge for the selected model
  if (renderer.xr.isPresenting || !selectedEntry) return;
  if (document.activeElement?.tagName === 'INPUT') return;
  let moved = true;
  switch (e.key) {
    case 'ArrowLeft':  selectedEntry.mesh.position.x -= NUDGE_STEP; break;
    case 'ArrowRight': selectedEntry.mesh.position.x += NUDGE_STEP; break;
    case 'ArrowUp':    selectedEntry.mesh.position.z -= NUDGE_STEP; break;
    case 'ArrowDown':  selectedEntry.mesh.position.z += NUDGE_STEP; break;
    default: moved = false;
  }
  if (moved) e.preventDefault();
});

</script>
<!-- ─── Model Browser Overlay ─────────────────────────────────────────────── -->
<div id="model-browser">
  <div class="mb-panel">
    <div class="mb-header">
      <span class="mb-title">Browse Official Models</span>
      <button class="mb-close" id="btn-mb-close" title="Close">✕</button>
    </div>
    <div class="mb-search-wrap">
      <span class="mb-search-icon">⌕</span>
      <input
        type="text"
        class="mb-search"
        id="mb-search-input"
        placeholder="Type 3+ characters to search… (e.g. 7140, AT-ST, xwing)"
        autocomplete="off"
        spellcheck="false"
      >
    </div>
    <div class="mb-status" id="mb-status">Loading model list…</div>
    <div class="mb-results" id="mb-results">
      <div class="mb-loading-indicator">Fetching model list from GitHub…</div>
    </div>
  </div>
</div>
</body>
</html>
