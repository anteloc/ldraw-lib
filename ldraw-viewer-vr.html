<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LDraw Model Viewer v5</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;800&display=swap');
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0e0e10; --panel: #16161a; --border: #2a2a30;
    --accent: #ffcc00; --accent-mr: #00ddff; --text: #e8e8ec; --muted: #6b6b78;
  }
  body { background: var(--bg); color: var(--text); font-family: 'Syne', sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
  header { display: flex; align-items: center; justify-content: space-between; padding: 12px 24px; border-bottom: 1px solid var(--border); background: var(--panel); flex-shrink: 0; }
  .logo { display: flex; align-items: center; gap: 10px; }
  .logo-brick { width: 28px; height: 20px; background: var(--accent); border-radius: 2px; position: relative; }
  .logo-brick::before, .logo-brick::after { content: ''; position: absolute; top: -7px; width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
  .logo-brick::before { left: 4px; } .logo-brick::after { right: 4px; }
  .logo h1 { font-size: 16px; font-weight: 800; letter-spacing: .05em; text-transform: uppercase; }
  .logo span { color: var(--accent); }
  .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .btn { font-family: 'Space Mono', monospace; font-size: 11px; padding: 7px 14px; border-radius: 4px; border: 1px solid var(--border); background: transparent; color: var(--text); cursor: pointer; text-transform: uppercase; letter-spacing: .08em; transition: all .15s; white-space: nowrap; }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn.primary { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 700; }
  .btn.primary:hover { background: #ffd633; }
  /* MR button gets a cyan accent */
  .btn.mr-btn { border-color: var(--accent-mr); color: var(--accent-mr); }
  .btn.mr-btn:hover { background: var(--accent-mr); color: #000; }
  .btn.mr-btn:disabled { border-color: var(--border); color: var(--muted); cursor: not-allowed; }
  .workspace { flex: 1; display: flex; overflow: hidden; }
  #canvas-container { flex: 1; position: relative; background: radial-gradient(ellipse at center, #1a1a2e 0%, #0e0e10 70%); }
  canvas { display: block; }
  .sidebar { width: 220px; background: var(--panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; flex-shrink: 0; overflow-y: auto; }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); }
  .sidebar-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: .15em; color: var(--muted); margin-bottom: 12px; }
  .info-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 6px; font-family: 'Space Mono', monospace; }
  .info-row .label { color: var(--muted); }
  .info-row .value { color: var(--text); }
  .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
  .toggle-label { font-size: 11px; font-family: 'Space Mono', monospace; text-transform: uppercase; letter-spacing: .05em; }
  .toggle { width: 34px; height: 18px; background: var(--border); border-radius: 9px; cursor: pointer; position: relative; transition: background .2s; }
  .toggle.on { background: var(--accent); }
  .toggle::after { content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: left .2s; }
  .toggle.on::after { left: 18px; }
  .hint { font-size: 10px; color: var(--muted); font-family: 'Space Mono', monospace; line-height: 1.8; }
  .hint b { color: var(--text); }
  .url-input { width: 100%; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 7px 8px; color: var(--text); font-family: 'Space Mono', monospace; font-size: 10px; margin-bottom: 6px; outline: none; }
  .url-input:focus { border-color: var(--accent); }
  .url-input::placeholder { color: var(--muted); }
  #drop-zone { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; cursor: pointer; }
  .drop-icon { width: 80px; height: 56px; border: 2px dashed var(--border); border-radius: 8px; display: flex; align-items: center; justify-content: center; transition: all .2s; }
  .drop-zone-brick { width: 36px; height: 24px; background: var(--border); border-radius: 2px; position: relative; transition: background .2s; }
  .drop-zone-brick::before, .drop-zone-brick::after { content: ''; position: absolute; top: -9px; width: 10px; height: 10px; background: var(--border); border-radius: 50%; transition: background .2s; }
  .drop-zone-brick::before { left: 5px; } .drop-zone-brick::after { right: 5px; }
  .drop-text { text-align: center; }
  .drop-text h2 { font-size: 15px; font-weight: 600; }
  .drop-text p { font-size: 11px; color: var(--muted); font-family: 'Space Mono', monospace; margin-top: 4px; }
  #drop-zone.dragging .drop-icon, #drop-zone:hover .drop-icon { border-color: var(--accent); }
  #drop-zone.dragging .drop-zone-brick, #drop-zone:hover .drop-zone-brick,
  #drop-zone.dragging .drop-zone-brick::before, #drop-zone.dragging .drop-zone-brick::after,
  #drop-zone:hover .drop-zone-brick::before, #drop-zone:hover .drop-zone-brick::after { background: var(--accent); }
  #loading-overlay { display: none; position: absolute; inset: 0; background: rgba(14,14,16,.8); align-items: center; justify-content: center; flex-direction: column; gap: 14px; }
  #loading-overlay.visible { display: flex; }
  .spinner { width: 32px; height: 32px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin .8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-family: 'Space Mono', monospace; font-size: 12px; color: var(--text); }
  .loading-sub { font-family: 'Space Mono', monospace; font-size: 10px; color: var(--muted); max-width: 280px; text-align: center; line-height: 1.6; }
  #status { position: absolute; bottom: 16px; left: 16px; font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted); pointer-events: none; }
  /* Mode badge — shown in VR/MR so user knows what mode they entered */
  #mode-badge { position: absolute; top: 16px; right: 16px; font-family: 'Space Mono', monospace; font-size: 10px; padding: 4px 10px; border-radius: 3px; display: none; pointer-events: none; }
  #mode-badge.vr { display: block; background: rgba(255,204,0,.15); border: 1px solid var(--accent); color: var(--accent); }
  #mode-badge.mr { display: block; background: rgba(0,221,255,.15); border: 1px solid var(--accent-mr); color: var(--accent-mr); }
  #file-input { display: none; }
  .error-banner { display: none; position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: #2a1010; border: 1px solid #663333; border-radius: 6px; padding: 12px 20px; max-width: 420px; width: 90%; z-index: 10; }
  .error-banner.visible { display: flex; align-items: flex-start; gap: 10px; }
  .error-banner-text { flex: 1; font-size: 11px; font-family: 'Space Mono', monospace; color: #ff8888; line-height: 1.6; white-space: pre-wrap; }
  .error-close { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 16px; line-height: 1; padding: 0; flex-shrink: 0; }
  /* MR shadow catcher — a subtle disc under the model in MR */
  /* (handled via Three.js object, no CSS needed) */

  /* ─── Model Browser Overlay ─────────────────────────────────────────────── */
  #model-browser {
    display: none;
    position: fixed; inset: 0; z-index: 100;
    background: rgba(8,8,10,.85);
    backdrop-filter: blur(6px);
    align-items: flex-start; justify-content: center;
    padding-top: 80px;
  }
  #model-browser.open { display: flex; }

  .mb-panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    width: 560px; max-width: 95vw;
    max-height: 70vh;
    display: flex; flex-direction: column;
    box-shadow: 0 24px 64px rgba(0,0,0,.6);
    overflow: hidden;
  }

  .mb-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .mb-title {
    font-size: 11px; font-weight: 700; text-transform: uppercase;
    letter-spacing: .15em; color: var(--muted);
  }
  .mb-close {
    background: none; border: none; color: var(--muted);
    cursor: pointer; font-size: 18px; line-height: 1; padding: 0;
    transition: color .15s;
  }
  .mb-close:hover { color: var(--text); }

  .mb-search-wrap {
    padding: 14px 20px 10px;
    flex-shrink: 0;
    position: relative;
  }
  .mb-search {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 10px 14px 10px 36px;
    color: var(--text);
    font-family: 'Space Mono', monospace;
    font-size: 12px;
    outline: none;
    transition: border-color .15s;
  }
  .mb-search:focus { border-color: var(--accent); }
  .mb-search::placeholder { color: var(--muted); }
  .mb-search-icon {
    position: absolute; left: 33px; top: 50%; transform: translateY(-50%);
    color: var(--muted); font-size: 14px; pointer-events: none;
  }

  .mb-status {
    padding: 0 20px 8px;
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    flex-shrink: 0;
    min-height: 22px;
  }

  .mb-results {
    flex: 1; overflow-y: auto;
    padding: 0 12px 12px;
  }
  /* Custom scrollbar */
  .mb-results::-webkit-scrollbar { width: 4px; }
  .mb-results::-webkit-scrollbar-track { background: transparent; }
  .mb-results::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .mb-result {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 12px;
    border-radius: 4px;
    border: 1px solid transparent;
    cursor: pointer;
    transition: all .12s;
    margin-bottom: 4px;
    gap: 12px;
  }
  .mb-result:hover { background: rgba(255,255,255,.04); border-color: var(--border); }
  .mb-result.focused { background: rgba(255,204,0,.07); border-color: rgba(255,204,0,.3); }

  .mb-result-name {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text);
    flex: 1;
    word-break: break-all;
    line-height: 1.5;
  }
  /* Fuse.js highlight spans injected into name */
  .mb-result-name mark {
    background: none;
    color: var(--accent);
    font-weight: 700;
  }

  .mb-load-btn {
    font-family: 'Space Mono', monospace; font-size: 10px;
    padding: 5px 10px; border-radius: 3px;
    border: 1px solid var(--border); background: transparent;
    color: var(--muted); cursor: pointer; white-space: nowrap;
    transition: all .12s; flex-shrink: 0;
  }
  .mb-result:hover .mb-load-btn,
  .mb-result.focused .mb-load-btn { border-color: var(--accent); color: var(--accent); }

  .mb-empty {
    text-align: center; padding: 32px 20px;
    font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted);
    line-height: 1.8;
  }

  .mb-loading-indicator {
    text-align: center; padding: 24px;
    font-family: 'Space Mono', monospace; font-size: 11px; color: var(--muted);
  }

  /* ─── Scene model list ───────────────────────────────────────────────────── */
  .model-list-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 0; gap: 8px; border-bottom: 1px solid var(--border);
  }
  .model-list-item:last-child { border-bottom: none; }
  .model-list-name {
    font-family: 'Space Mono', monospace; font-size: 10px; color: var(--text);
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .model-list-remove {
    background: none; border: none; color: var(--muted); cursor: pointer;
    font-size: 14px; line-height: 1; padding: 0 2px; flex-shrink: 0;
    transition: color .15s;
  }
  .model-list-remove:hover { color: #ff5555; }
  .model-list-empty {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); font-style: italic;
  }
  .model-list-count {
    font-family: 'Space Mono', monospace; font-size: 10px;
    color: var(--muted); margin-bottom: 8px;
  }

</style>
</head>
<body>

<header>
  <div class="logo">
    <div class="logo-brick"></div>
    <h1>LDraw <span>Viewer</span> <span style="font-size:11px;opacity:.4;color:var(--text)">v5</span></h1>
  </div>
  <div class="controls">
    <button class="btn" id="btn-demo">Load Demo</button>
    <button class="btn" id="btn-browse" onclick="openModelBrowser()">Browse Models</button>
    <button class="btn" onclick="resetView()">Reset View</button>
    <button class="btn primary" onclick="document.getElementById('file-input').click()">Open File</button>
    <input type="file" id="file-input" accept=".ldr,.mpd,.dat">
    <!-- VR and MR buttons are injected here by JS after checking support -->
  </div>
</header>

<div class="workspace">
  <div id="canvas-container">
    <div id="drop-zone">
      <div class="drop-icon"><div class="drop-zone-brick"></div></div>
      <div class="drop-text">
        <h2>Drop LDraw File</h2>
        <p>.ldr &nbsp;·&nbsp; .mpd &nbsp;·&nbsp; .dat</p>
        <p style="margin-top:10px;font-size:10px;opacity:.6">Packed .mpd files work best<br>sub-parts are self-contained</p>
      </div>
    </div>
    <div id="loading-overlay">
      <div class="spinner"></div>
      <div class="loading-text" id="loading-msg">Loading…</div>
      <div class="loading-sub" id="loading-sub"></div>
    </div>
    <div class="error-banner" id="error-banner">
      <div class="error-banner-text" id="error-text"></div>
      <button class="error-close" onclick="document.getElementById('error-banner').classList.remove('visible')">✕</button>
    </div>
    <div id="mode-badge"></div>
    <div id="status">No model loaded</div>
  </div>

  <div class="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">Scene</div>
      <div class="model-list-count" id="scene-count">No models loaded</div>
      <div id="scene-model-list"><span class="model-list-empty">—</span></div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Display</div>
      <div class="toggle-row">
        <span class="toggle-label">Edges</span>
        <div class="toggle on" id="toggle-edges" onclick="toggleEdges()"></div>
      </div>
      <div class="toggle-row">
        <span class="toggle-label">Grid</span>
        <div class="toggle on" id="toggle-grid" onclick="toggleGrid()"></div>
      </div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Load URL</div>
      <input type="text" class="url-input" id="url-input" placeholder="https://…/model.mpd">
      <button class="btn" style="width:100%;margin-top:2px" onclick="loadFromURL()">Load</button>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Browser Controls</div>
      <div class="hint">
        Left drag — Orbit<br>
        Right drag — Pan<br>
        Scroll — Zoom<br>
        Double-click — Focus
      </div>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">VR / MR Controls</div>
      <div class="hint">
        Aim at a model, then:<br>
        <b>Grip</b> — grab &amp; move<br>
        <b>Trigger</b> — rotate<br>
        <b>Thumbstick ↑↓</b> — scale<br>
        <b>B / Y</b> — remove model<br>
        <br>
        White ray = ready<br>
        Red ray = active<br>
        <br>
        <b>MR mode:</b> models float<br>
        in your real room.
      </div>
    </div>
    <div class="sidebar-section" style="flex:1">
      <div class="sidebar-title">File Format Tips</div>
      <div class="hint">
        Packed .mpd files load<br>fully self-contained.<br><br>
        Plain .ldr files need<br>sub-parts fetched from<br>the LDraw CDN — requires<br>internet access.
      </div>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
    "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.4/src/index.js"
  }
}
</script>

<!-- Fuse.js for fuzzy search -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/7.0.0/fuse.min.js"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls }  from 'three/addons/controls/OrbitControls.js';
import { LDrawLoader }    from 'three/addons/loaders/LDrawLoader.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
import { VRButton }                from 'three/addons/webxr/VRButton.js';
import { ARButton }                from 'three/addons/webxr/ARButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';

// Patch Three.js prototypes once — every Mesh and BufferGeometry in the scene
// automatically gets BVH-accelerated raycasting after this point.
THREE.BufferGeometry.prototype.computeBoundsTree  = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree  = disposeBoundsTree;
THREE.Mesh.prototype.raycast                      = acceleratedRaycast;

// ─── Models and parts URLs ────────────────────────────────────────────────────
const BASE_REPO = 'anteloc/ldraw-lib';
const REPO_BRANCH = 'test-scheduled-updates';
const PARTS_CDN = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/ldraw/`;
const DEMO_MODEL = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/ldraw/models/car.ldr`;
const GITHUB_API = `https://api.github.com/repos/${BASE_REPO}/contents/models?ref=${REPO_BRANCH}`;
const RAW_BASE   = `https://raw.githubusercontent.com/${BASE_REPO}/${REPO_BRANCH}/models/`;

// ─── Renderer ─────────────────────────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;    // PCFSoft is overkill; PCF is a good balance
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);

// ─── Scene ────────────────────────────────────────────────────────────────────
const scene = new THREE.Scene();
// Keep track of the "normal" browser background so we can restore it after MR
const BROWSER_BG = new THREE.Color(0x0e0e10);
scene.background = BROWSER_BG;

const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;

// ─── Camera & browser controls ────────────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 50000);
camera.position.set(0, 400, 1200);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

// ─── Lights ───────────────────────────────────────────────────────────────────
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
dirLight.position.set(500, 1000, 500);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(1024, 1024);
Object.assign(dirLight.shadow.camera, { near: 1, far: 10000, left: -2000, right: 2000, top: 2000, bottom: -2000 });
scene.add(dirLight);

// ─── Grid & shadow ground (browser / VR only, hidden in MR) ──────────────────
const gridHelper = new THREE.GridHelper(4000, 50, 0x333344, 0x222230);
scene.add(gridHelper);

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(10000, 10000),
  new THREE.ShadowMaterial({ opacity: 0.2 })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ─── MR shadow disc ───────────────────────────────────────────────────────────
// In MR we hide the opaque grid but show a subtle circular shadow beneath the
// model so it feels anchored to the surface rather than floating in mid-air.
const mrShadowDisc = new THREE.Mesh(
  new THREE.CircleGeometry(0.18, 64),
  new THREE.MeshBasicMaterial({
    color: 0x000000,
    transparent: true,
    opacity: 0.25,
    depthWrite: false,
  })
);
mrShadowDisc.rotation.x = -Math.PI / 2;
mrShadowDisc.visible = false; // shown only in MR
scene.add(mrShadowDisc);

// ─── Resize ───────────────────────────────────────────────────────────────────
function resize() {
  const w = container.clientWidth, h = container.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
resize();
window.addEventListener('resize', resize);

// ─── XR scene-root hierarchy ──────────────────────────────────────────────────
//
// Each loaded model lives in a ModelEntry:
//
//   scene
//     ├── (browser) entry.mesh   ← normal scale, LDU units
//     └── entry.pivot            ← world position of model in XR
//           └── entry.root       ← uniform scale (LDU→metres) + rotation
//                 └── (XR) entry.mesh
//
// LDU → metres: 1 LDU = 0.4 mm = 0.0004 m, ×2.5 = hand-held / table-top scale
const LDU_TO_METERS = 0.0004 * 2.5;

// ── ModelEntry — one per loaded model ─────────────────────────────────────────
//
//   { mesh, pivot, root, name }
//
const MAX_MODELS      = 5;
const MODEL_SPACING   = 0.35;   // metres between model pivots in XR
const MODEL_PIVOT_Y   = 0.9;    // metres above floor
const MODEL_PIVOT_Z   = -0.6;   // metres in front of user

// All currently loaded models, in load order.
const models = [];

function createEntry(mesh, name) {
  // Place new entry to the right of all existing ones
  const pivotX = models.reduce(
    (maxX, e) => Math.max(maxX, e.pivot.position.x),
    0
  ) + (models.length > 0 ? MODEL_SPACING : 0);

  const pivot = new THREE.Group();
  pivot.position.set(pivotX, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
  scene.add(pivot);

  const root = new THREE.Group();
  root.scale.setScalar(LDU_TO_METERS);
  pivot.add(root);

  return { mesh, pivot, root, name };
}

// ─── XR controllers ───────────────────────────────────────────────────────────
//
// Three.js exposes two separate tracked spaces per physical controller:
//   getController(i)     → pointer / target-ray space  (laser origin)
//   getControllerGrip(i) → grip space                  (where the hand holds it)
//
// The controller model from XRControllerModelFactory must be attached to the
// grip space; the laser must be attached to the pointer space.
// Both are added to the scene and their poses are updated automatically by the
// XR runtime each frame — no manual position/quaternion sync needed.

const controllerModelFactory = new XRControllerModelFactory();

// ── Laser constants ────────────────────────────────────────────────────────────
const LASER_LENGTH        = 5;      // metres
const LASER_RADIUS        = 0.003;  // metres — visible thickness in VR
const COLOR_IDLE          = 0xffffff;
const COLOR_GRABBED       = 0xff2222;
const ROTATE_SENSITIVITY  = 10.0;   // rotation speed multiplier
const SCALE_SPEED         = 0.02;   // scale change per frame at full thumbstick deflection
// Raycasting throttle: when no gesture is active, only raycast every N frames.
// At 72fps, N=3 gives ~24 laser updates/sec — imperceptible for idle aiming.
// Active gestures always raycast every frame for precision.
const RAYCAST_IDLE_INTERVAL = 3;
let   _frameCount           = 0;

// ── Laser builder — returns a Group (cylinder beam + tip ring) ─────────────────
//
// A CylinderGeometry is used instead of Line because WebGL does not support
// line widths > 1px on most drivers, making Line invisible at VR scale.
// The cylinder is oriented along –Z (the pointer forward direction).
function makeLaser() {
  const group = new THREE.Group();

  // Beam — thin cylinder from origin to LASER_LENGTH along –Z
  const beamMat = new THREE.MeshBasicMaterial({ color: COLOR_IDLE, transparent: true, opacity: 0.6 });
  const beam = new THREE.Mesh(new THREE.CylinderGeometry(LASER_RADIUS, LASER_RADIUS, LASER_LENGTH, 8), beamMat);
  // CylinderGeometry stands along Y; rotate and translate so it lies along –Z
  beam.rotation.x = Math.PI / 2;
  beam.position.z = -LASER_LENGTH / 2;
  group.add(beam);

  // Tip ring — faces along the ray axis (perpendicular to –Z)
  const ringMat = new THREE.MeshBasicMaterial({ color: COLOR_IDLE, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
  const ring = new THREE.Mesh(new THREE.RingGeometry(0.006, 0.012, 32), ringMat);
  ring.position.z = -LASER_LENGTH;
  group.add(ring);

  return group;
}

// ── Set the laser color on a pointer controller ────────────────────────────────
function setLaserColor(pointer, color) {
  // laser group is the first (and only) child of the pointer space
  pointer.children[0].traverse(child => {
    if (child.material) child.material.color.setHex(color);
  });
}

// ── Build both controllers ─────────────────────────────────────────────────────
function buildController(index) {
  // Pointer space — laser lives here
  const pointer = renderer.xr.getController(index);
  pointer.add(makeLaser());
  scene.add(pointer);

  // Grip space — hardware model lives here
  const grip = renderer.xr.getControllerGrip(index);
  grip.add(controllerModelFactory.createControllerModel(grip));
  scene.add(grip);

  return { pointer, grip };
}

const controllers = [buildController(0), buildController(1)];

// ── Reusable temporaries (never allocated per-frame) ──────────────────────────
const _ctrlWorldPos  = new THREE.Vector3();
const _ctrlWorldQuat = new THREE.Quaternion();
const _ctrlWorldQInv = new THREE.Quaternion();
const _raycaster     = new THREE.Raycaster();
_raycaster.firstHitOnly = true;   // BVH short-circuits after first hit — much faster
const _rayOrigin     = new THREE.Vector3();
const _rayDir        = new THREE.Vector3();
const _fingerDelta   = new THREE.Vector3();
const _oldArm        = new THREE.Vector3();
const _newArm        = new THREE.Vector3();
const _rotQuat       = new THREE.Quaternion();

// ── Laser shortening ───────────────────────────────────────────────────────────
//
// Called every frame for each controller. Casts a ray from the pointer against
// the current model, then scales the beam and repositions the tip ring to the
// hit point (or restores full length on a miss).
// Returns the hit point in world space, or null if the ray missed.
//
function updateLaser(pointer) {
  const beam = pointer.children[0].children[0];
  const ring = pointer.children[0].children[1];

  if (models.length === 0) {
    beam.scale.z = 1;
    ring.position.z = -LASER_LENGTH;
    return { hitPoint: null, hitEntry: null };
  }

  pointer.getWorldPosition(_rayOrigin);
  _rayDir.set(0, 0, -1).transformDirection(pointer.matrixWorld);
  _raycaster.set(_rayOrigin, _rayDir);

  // Test all loaded meshes; pick the nearest hit across all of them
  let nearestDist  = Infinity;
  let nearestPoint = null;
  let nearestEntry = null;

  for (const entry of models) {
    const hits = _raycaster.intersectObject(entry.mesh, /* recursive */ true);
    if (hits.length > 0 && hits[0].distance < nearestDist) {
      nearestDist  = hits[0].distance;
      nearestPoint = hits[0].point;
      nearestEntry = entry;
    }
  }

  if (nearestEntry === null) {
    beam.scale.z = 1;
    ring.position.z = -LASER_LENGTH;
    return { hitPoint: null, hitEntry: null };
  }

  beam.scale.z = nearestDist / LASER_LENGTH;
  ring.position.z = -nearestDist;
  return { hitPoint: nearestPoint, hitEntry: nearestEntry };
}

// ── Per-controller interaction slots ──────────────────────────────────────────
//
// Each physical controller has its own independent slot so both hands can
// interact with different models simultaneously.
//
// slot.type      — null | 'grab' | 'rotate'
// slot.grab      — grab state, valid while type === 'grab'
// slot.rotate    — rotate state, valid while type === 'rotate'
//
// Cross-controller rule: two grabs on the *same* model are denied — they would
// fight each other. Any other combination (grab A + rotate A, grab A + rotate B,
// grab A + grab B) is allowed.
//
function makeSlot() {
  return {
    type:    null,
    pointer: null,
    grab: {
      entry:      null,
      offsetPos:  new THREE.Vector3(),
      offsetQuat: new THREE.Quaternion(),
    },
    rotate: {
      entry:           null,
      touchPointLocal: new THREE.Vector3(),
      prevFingerPos:   new THREE.Vector3(),
    },
  };
}

const slots = [makeSlot(), makeSlot()];

// ── Slot helpers ───────────────────────────────────────────────────────────────
function otherSlot(slot) {
  return slots[slots.indexOf(slot) === 0 ? 1 : 0];
}

function startGrab(slot, pointer, hitPoint, hitEntry) {
  // Deny if the other hand is already grabbing the same model
  const other = otherSlot(slot);
  if (other.type === 'grab' && other.grab.entry === hitEntry) return;

  const { pivot, root } = hitEntry;
  pointer.getWorldPosition(_ctrlWorldPos);
  pointer.getWorldQuaternion(_ctrlWorldQuat);
  _ctrlWorldQInv.copy(_ctrlWorldQuat).invert();

  slot.grab.entry = hitEntry;
  slot.grab.offsetPos
    .copy(pivot.position)
    .sub(_ctrlWorldPos)
    .applyQuaternion(_ctrlWorldQInv);
  slot.grab.offsetQuat
    .multiplyQuaternions(_ctrlWorldQInv, root.getWorldQuaternion(new THREE.Quaternion()));

  slot.type    = 'grab';
  slot.pointer = pointer;
  setLaserColor(pointer, COLOR_GRABBED);
}

function startRotate(slot, pointer, hitPoint, hitEntry) {
  slot.rotate.entry = hitEntry;
  hitEntry.root.worldToLocal(slot.rotate.touchPointLocal.copy(hitPoint));
  pointer.getWorldPosition(slot.rotate.prevFingerPos);

  slot.type    = 'rotate';
  slot.pointer = pointer;
  setLaserColor(pointer, COLOR_GRABBED);
}

function endInteraction(slot) {
  if (!slot.type) return;
  if (slot.pointer) setLaserColor(slot.pointer, COLOR_IDLE);
  slot.type           = null;
  slot.pointer        = null;
  slot.grab.entry     = null;
  slot.rotate.entry   = null;
}

// ── Wire interaction events on both controllers ────────────────────────────────
for (let i = 0; i < controllers.length; i++) {
  const { pointer } = controllers[i];
  const slot = slots[i];

  pointer.addEventListener('connected',    e => { pointer.userData.xrInputSource = e.data; });
  pointer.addEventListener('disconnected', () => { pointer.userData.xrInputSource = null; });

  pointer.addEventListener('squeezestart', () => {
    if (slot.type) return;   // this controller is busy
    const { hitPoint, hitEntry } = pointer.userData;
    if (!hitEntry) return;
    startGrab(slot, pointer, hitPoint, hitEntry);
  });
  pointer.addEventListener('squeezeend', () => {
    if (slot.type === 'grab') endInteraction(slot);
  });

  pointer.addEventListener('selectstart', () => {
    if (slot.type) return;   // this controller is busy
    const { hitPoint, hitEntry } = pointer.userData;
    if (!hitEntry) return;
    startRotate(slot, pointer, hitPoint, hitEntry);
  });
  pointer.addEventListener('selectend', () => {
    if (slot.type === 'rotate') endInteraction(slot);
  });
}

// ── Apply one grab slot ────────────────────────────────────────────────────────
function applyGrab(slot) {
  const { pivot, root } = slot.grab.entry;
  const ctrl = slot.pointer;
  ctrl.getWorldPosition(_ctrlWorldPos);
  ctrl.getWorldQuaternion(_ctrlWorldQuat);

  pivot.position
    .copy(slot.grab.offsetPos)
    .applyQuaternion(_ctrlWorldQuat)
    .add(_ctrlWorldPos);

  root.quaternion.multiplyQuaternions(_ctrlWorldQuat, slot.grab.offsetQuat);

  mrShadowDisc.position.x = pivot.position.x;
  mrShadowDisc.position.z = pivot.position.z;
}

// ── Apply one rotate slot ──────────────────────────────────────────────────────
function applyRotate(slot) {
  const ctrl = slot.pointer;

  // Finger lifted — ray no longer on this model, pause rotation
  if (ctrl.userData.hitEntry !== slot.rotate.entry) {
    ctrl.getWorldPosition(slot.rotate.prevFingerPos);
    return;
  }

  ctrl.getWorldPosition(_ctrlWorldPos);
  _fingerDelta.subVectors(_ctrlWorldPos, slot.rotate.prevFingerPos);

  if (_fingerDelta.lengthSq() > 0) {
    const { root } = slot.rotate.entry;

    root.getWorldPosition(_newArm);                 // centroid
    _oldArm.copy(slot.rotate.touchPointLocal)
      .applyMatrix4(root.matrixWorld)
      .sub(_newArm);                                // arm: centroid → touch point

    _newArm.copy(_oldArm).addScaledVector(_fingerDelta, ROTATE_SENSITIVITY);
    _newArm.setLength(_oldArm.length());

    _rotQuat.setFromUnitVectors(_oldArm.normalize(), _newArm.normalize());
    root.quaternion.premultiply(_rotQuat);
  }

  slot.rotate.prevFingerPos.copy(_ctrlWorldPos);
}

// ── Main XR update — called every frame while presenting ──────────────────────
function updateXRControls() {
  _frameCount++;

  // 1. Update laser visuals — throttled when idle, every frame when active.
  //    Active = at least one slot has an ongoing gesture.
  const anyActive = slots.some(s => s.type !== null);
  const doRaycast = anyActive || (_frameCount % RAYCAST_IDLE_INTERVAL === 0);

  if (doRaycast) {
    for (const { pointer } of controllers) {
      const result = updateLaser(pointer);
      pointer.userData.hitPoint = result.hitPoint;
      pointer.userData.hitEntry = result.hitEntry;
    }
  }

  // 2. Apply both interaction slots independently
  for (const slot of slots) {
    if (slot.type === 'grab')   applyGrab(slot);
    if (slot.type === 'rotate') applyRotate(slot);
  }

  // 3. Thumbstick scaling — active on any controller whose laser hits a model
  for (const { pointer } of controllers) {
    const entry = pointer.userData.hitEntry;
    if (!entry) continue;

    const source = pointer.userData.xrInputSource;
    if (!source?.gamepad) continue;

    const thumbY = source.gamepad.axes[3] ?? 0;
    if (Math.abs(thumbY) <= 0.1) continue;

    const newScale = THREE.MathUtils.clamp(
      entry.root.scale.x * (1 + thumbY * SCALE_SPEED),
      LDU_TO_METERS * 0.05,
      LDU_TO_METERS * 30
    );
    entry.root.scale.setScalar(newScale);
    mrShadowDisc.scale.setScalar(newScale / LDU_TO_METERS);
  }

  // 4. B/Y button — remove the model the laser is currently hitting.
  //    Rising-edge detection fires exactly once per press.
  for (const { pointer } of controllers) {
    const source = pointer.userData.xrInputSource;
    const pressed    = source?.gamepad?.buttons[5]?.pressed ?? false;
    const wasPressed = pointer.userData.prevBYPressed ?? false;
    pointer.userData.prevBYPressed = pressed;

    if (pressed && !wasPressed) {
      const entry = pointer.userData.hitEntry;
      if (entry) removeEntry(entry);
    }
  }
}

// ─── Animation loop ───────────────────────────────────────────────────────────
// IMPORTANT: controls.update() must NOT run while XR is presenting.
// The XR runtime owns the camera pose during a session. If OrbitControls
// also runs update() every frame — even with enabled=false, the damping
// momentum still nudges camera.position — it fights the XR pose tracker
// and produces the rapid head-movement jitter.
renderer.setAnimationLoop((timestamp, frame) => {
  if (renderer.xr.isPresenting && frame) {
    updateXRControls();
  } else {
    controls.update(); // only touch the camera in browser mode
  }
  renderer.render(scene, camera);
});

// ─── Mode tracking ────────────────────────────────────────────────────────────
// 'browser' | 'vr' | 'mr'
let currentMode = 'browser';
const modeBadge = document.getElementById('mode-badge');

function setMode(mode) {
  currentMode = mode;
  modeBadge.className = '';
  if (mode === 'vr') { modeBadge.className = 'vr'; modeBadge.textContent = '● VR'; }
  if (mode === 'mr') { modeBadge.className = 'mr'; modeBadge.textContent = '● MR'; }
}

// ─── Shared XR session start / end logic ─────────────────────────────────────
function onXRSessionStart(mode) {
  setMode(mode);

  // ── Flush OrbitControls damping before handing camera to XR ──────────────
  // Even with controls.enabled = false, controls.update() with dampingFactor
  // > 0 keeps applying residual momentum to camera.position every frame.
  // Drain that momentum NOW before the XR runtime takes ownership of the
  // camera, so there is zero leftover delta fighting the head-pose tracker.
  controls.saveState();           // snapshot so we can restore on session end
  controls.dampingFactor = 0;     // kill damping temporarily
  controls.update();              // one tick to flush pending delta to zero
  controls.dampingFactor = 0.06;  // restore (won't run again until session ends)
  controls.enabled = false;       // disable input handling

  gridHelper.visible = false;
  ground.visible = false;
  dirLight.castShadow = false;   // shadows off in XR — saves a full shadow map render every frame

  if (mode === 'mr') {
    // Transparent background → passthrough shows through
    scene.background = null;
    renderer.setClearColor(0x000000, 0);
    // Boost ambient slightly so model isn't too dark against bright room
    ambientLight.intensity = 1.2;
    mrShadowDisc.visible = true;
  } else {
    // VR: solid opaque black — gives the XR compositor a proper opaque layer.
    // null/transparent in VR causes the compositor to blend against undefined
    // content, contributing to silhouette-edge flicker.
    scene.background = new THREE.Color(0x000000);
    renderer.setClearColor(0x000000, 1);
    ambientLight.intensity = 0.6;
    mrShadowDisc.visible = false;
  }

  for (const entry of models) {
    const { mesh, pivot, root } = entry;
    scene.remove(mesh);
    root.add(mesh);
    // Re-centre so rotation pivots around model centre
    const box = new THREE.Box3().setFromObject(mesh);
    const centre = box.getCenter(new THREE.Vector3());
    mesh.position.sub(centre);
    // Position shadow disc under first model pivot at floor level (approximation)
    if (mode === 'mr') {
      mrShadowDisc.position.set(pivot.position.x, pivot.position.y - 0.88, pivot.position.z);
    }
  }

}

function onXRSessionEnd() {
  setMode('browser');

  // Drop all active interactions and reset laser colors
  for (const slot of slots) endInteraction(slot);
  for (const { pointer } of controllers) {
    setLaserColor(pointer, COLOR_IDLE);
    pointer.userData.hitPoint      = null;
    pointer.userData.hitEntry      = null;
    pointer.userData.xrInputSource = null;
    pointer.userData.prevBYPressed = false;
  }

  // Restore OrbitControls to the exact state they were in before XR started
  controls.reset();       // returns to saveState() snapshot
  controls.enabled = true;

  // Restore browser visuals
  scene.background = BROWSER_BG;
  renderer.setClearColor(0x000000, 1);
  ambientLight.intensity = 0.6;
  gridHelper.visible = document.getElementById('toggle-grid').classList.contains('on');
  ground.visible = true;
  dirLight.castShadow = true;
  mrShadowDisc.visible = false;

  // Return all models to scene root
  for (const entry of models) {
    const { mesh, pivot, root } = entry;
    root.remove(mesh);
    mesh.position.set(0, 0, 0);
    scene.add(mesh);
    // Reset XR transforms for next session
    root.scale.setScalar(LDU_TO_METERS);
    root.rotation.set(0, 0, 0);
  }
  if (models.length > 0) fitCamera();
}

renderer.xr.addEventListener('sessionstart', () => {
  // Determine if this is VR or MR by inspecting the active session mode
  const session = renderer.xr.getSession();
  const mode = session?.environmentBlendMode === 'additive' ||
               session?.environmentBlendMode === 'alpha-blend'
               ? 'mr' : 'vr';
  onXRSessionStart(mode);
});
renderer.xr.addEventListener('sessionend', onXRSessionEnd);

// ─── VR Button ────────────────────────────────────────────────────────────────
function styleXRButton(btn, isMR) {
  Object.assign(btn.style, {
    position: 'static', background: 'transparent',
    fontFamily: "'Space Mono', monospace", fontSize: '11px',
    padding: '7px 14px', borderRadius: '4px', cursor: 'pointer',
    textTransform: 'uppercase', letterSpacing: '.08em', transition: 'all .15s',
    width: 'auto', bottom: 'auto', left: 'auto', right: 'auto',
    border: isMR ? '1px solid var(--accent-mr)' : '1px solid var(--border)',
    color: isMR ? 'var(--accent-mr)' : 'var(--text)',
  });
  btn.onmouseenter = () => {
    btn.style.background = isMR ? 'var(--accent-mr)' : 'var(--border)';
    btn.style.color = isMR ? '#000' : 'var(--accent)';
    if (!isMR) btn.style.borderColor = 'var(--accent)';
  };
  btn.onmouseleave = () => {
    btn.style.background = 'transparent';
    btn.style.color = isMR ? 'var(--accent-mr)' : 'var(--text)';
    btn.style.borderColor = isMR ? 'var(--accent-mr)' : 'var(--border)';
  };
}

const controlsBar = document.querySelector('.controls');

const vrButton = VRButton.createButton(renderer);
styleXRButton(vrButton, false);
controlsBar.prepend(vrButton);

// ARButton requires optionalFeatures for Quest 3 passthrough
const arButton = ARButton.createButton(renderer, {
  requiredFeatures: ['local-floor'],
  optionalFeatures: ['bounded-floor', 'hand-tracking'],
});
// Override the default label — ARButton says "START AR", we want "Enter MR"
// We watch for the button to become enabled and relabel it
const relabelAR = () => {
  if (arButton.textContent.includes('AR') || arButton.textContent.includes('SUPPORTED')) {
    arButton.textContent = arButton.disabled ? 'MR NOT SUPPORTED' : 'ENTER MR';
  }
};
new MutationObserver(relabelAR).observe(arButton, { childList: true, characterData: true, subtree: true });
relabelAR();

styleXRButton(arButton, true);
// Insert MR button right after VR button
vrButton.insertAdjacentElement('afterend', arButton);

// ─── LDraw & model state ──────────────────────────────────────────────────────
let edgesVisible  = true;

// ─── UI helpers ───────────────────────────────────────────────────────────────
const dropZone       = document.getElementById('drop-zone');
const loadingOverlay = document.getElementById('loading-overlay');
const loadingMsg     = document.getElementById('loading-msg');
const loadingSub     = document.getElementById('loading-sub');
const statusEl       = document.getElementById('status');
const errorBanner    = document.getElementById('error-banner');
const errorText      = document.getElementById('error-text');

function showLoading(msg, sub) {
  loadingMsg.textContent = msg || 'Loading…';
  loadingSub.textContent = sub || '';
  loadingOverlay.classList.add('visible');
  errorBanner.classList.remove('visible');
}
function hideLoading() { loadingOverlay.classList.remove('visible'); }
function showError(msg) { hideLoading(); errorText.textContent = msg; errorBanner.classList.add('visible'); }
function setStatus(s)   { statusEl.textContent = s; }

// ── Scene model list ───────────────────────────────────────────────────────────
const sceneCountEl    = document.getElementById('scene-count');
const sceneModelListEl = document.getElementById('scene-model-list');

function renderModelList() {
  sceneCountEl.textContent = models.length === 0
    ? 'No models loaded'
    : `${models.length} / ${MAX_MODELS} model${models.length > 1 ? 's' : ''}`;

  if (models.length === 0) {
    sceneModelListEl.innerHTML = '<span class="model-list-empty">—</span>';
    return;
  }

  sceneModelListEl.innerHTML = '';
  for (const entry of models) {
    const item = document.createElement('div');
    item.className = 'model-list-item';

    const nameEl = document.createElement('span');
    nameEl.className = 'model-list-name';
    nameEl.textContent = entry.name;
    nameEl.title = entry.name;

    const removeBtn = document.createElement('button');
    removeBtn.className = 'model-list-remove';
    removeBtn.textContent = '✕';
    removeBtn.title = 'Remove from scene';
    removeBtn.onclick = () => removeEntry(entry);

    item.append(nameEl, removeBtn);
    sceneModelListEl.appendChild(item);
  }
}

function removeEntry(entry) {
  // Release any slot whose interaction targets this entry
  for (const slot of slots) {
    if (slot.grab.entry === entry || slot.rotate.entry === entry) {
      endInteraction(slot);
    }
  }

  const { mesh, pivot, root } = entry;
  root.remove(mesh);
  scene.remove(mesh);
  scene.remove(pivot);
  mesh.traverse(o => {
    if (o.geometry) {
      o.geometry.disposeBoundsTree?.();
      o.geometry.dispose();
    }
    if (o.material) [].concat(o.material).forEach(m => m.dispose());
  });

  models.splice(models.indexOf(entry), 1);
  renderModelList();

  if (models.length === 0) {
    dropZone.style.display = '';
    setStatus('No model loaded');
  } else {
    fitCamera();
  }
}

function clearAllModels() {
  // Slice to avoid mutating while iterating
  for (const entry of models.slice()) removeEntry(entry);
}

function fitCamera() {
  if (models.length === 0) {
    camera.position.set(0, 400, 1200);
    controls.target.set(0, 0, 0);
    controls.update();
    return;
  }
  const box = new THREE.Box3();
  for (const entry of models) box.expandByObject(entry.mesh);
  const size   = box.getSize(new THREE.Vector3());
  const centre = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const dist   = (maxDim / (2 * Math.tan(camera.fov * Math.PI / 360))) * 1.6;
  controls.target.copy(centre);
  camera.position.set(centre.x + dist * 0.3, centre.y + dist * 0.4, centre.z + dist);
  controls.update();
  gridHelper.position.y = box.min.y;
  ground.position.y     = box.min.y;
}

function onModelLoaded(model, filename) {
  if (models.length >= MAX_MODELS) {
    showError(`Maximum ${MAX_MODELS} models in scene. Remove one first.`);
    return;
  }

  errorBanner.classList.remove('visible');
  model.rotation.x = Math.PI; // LDraw Y-down → Y-up
  model.traverse(o => {
    if (o.isMesh) {
      o.castShadow = true;
      o.receiveShadow = true;
      o.geometry.computeBoundsTree();   // BVH — O(log n) raycasts
    } else if (o.isLineSegments) {
      o.raycast = () => {};             // edges are visual only — never raycasted
    }
  });

  scene.add(model);
  const entry = createEntry(model, filename);
  models.push(entry);

  if (models.length === 1) dropZone.style.display = 'none';
  fitCamera();
  renderModelList();

  let meshes = 0, tris = 0;
  model.traverse(o => {
    if (o.isMesh) {
      meshes++;
      const idx = o.geometry.index;
      tris += idx ? idx.count / 3 : o.geometry.attributes.position.count / 3;
    }
  });

  hideLoading();
  setStatus(`Loaded: ${filename} (${models.length}/${MAX_MODELS} in scene)`);
}


function makeLoader() {
  const l = new LDrawLoader();
  l.setPartsLibraryPath(PARTS_CDN);
  return l;
}

function loadText(text, filename) {
  showLoading('Parsing model…', 'Sub-parts resolved from LDraw CDN — needs internet');
  const loader = makeLoader();
  loader.preloadMaterials(PARTS_CDN + 'LDConfig.ldr')
    .catch(() => {})
    .then(() => loader.parse(text,
      model => onModelLoaded(model, filename),
      err => {
        console.error(err);
        showError('Parse error: ' + (err?.message || String(err)) +
          '\n\nPacked .mpd files work best — all sub-parts are bundled inside.');
      }
    ));
}

// ─── Public API ───────────────────────────────────────────────────────────────
window.loadFile = function(file) {
  if (!file) return;
  showLoading('Reading file…', file.name);
  const reader = new FileReader();
  reader.onload = e => loadText(e.target.result, file.name);
  reader.onerror = () => showError('Could not read file.');
  reader.readAsText(file);
};

window.loadFromURL = function() {
  const url = document.getElementById('url-input').value.trim();
  if (!url) return;
  showLoading('Fetching…', url);
  const loader = makeLoader();
  loader.preloadMaterials(PARTS_CDN + 'LDConfig.ldr').catch(() => {}).then(() =>
    loader.load(url,
      model => onModelLoaded(model, url.split('/').pop()),
      xhr => { if (xhr.total) loadingSub.textContent = 'Downloading… ' + Math.round(xhr.loaded / xhr.total * 100) + '%'; },
      err => showError('Could not load URL — CORS may be blocking it.\nTry downloading and opening locally.\n\n' + err)
    )
  );
};

window.resetView = function() {
  if (renderer.xr.isPresenting) {
    let x = 0;
    for (const entry of models) {
      const { pivot, root } = entry;
      root.scale.setScalar(LDU_TO_METERS);
      root.rotation.set(0, 0, 0);
      pivot.position.set(x, MODEL_PIVOT_Y, MODEL_PIVOT_Z);
      x += MODEL_SPACING;
    }
    mrShadowDisc.position.set(0, MODEL_PIVOT_Y - 0.88, MODEL_PIVOT_Z);
    mrShadowDisc.scale.setScalar(1);
  } else {
    fitCamera();
  }
};

window.toggleEdges = function() {
  edgesVisible = !edgesVisible;
  document.getElementById('toggle-edges').classList.toggle('on', edgesVisible);
  for (const entry of models) {
    entry.mesh.traverse(o => { if (o.isLineSegments) o.visible = edgesVisible; });
  }
};

window.toggleGrid = function() {
  const on = !gridHelper.visible;
  gridHelper.visible = on;
  document.getElementById('toggle-grid').classList.toggle('on', on);
};

// ─── Demo model ───────────────────────────────────────────────────────────────
document.getElementById('btn-demo').addEventListener('click', () => {
  showLoading('Loading demo…', 'Fetching packed .mpd from three.js GitHub');
  const url = DEMO_MODEL;
  const loader = makeLoader();
  loader.load(url,
    model => onModelLoaded(model, 'car (demo)'),
    xhr => { if (xhr.total) loadingSub.textContent = 'Downloading… ' + Math.round(xhr.loaded / xhr.total * 100) + '%'; },
    err => showError('Could not load demo — check your internet connection.\n' + err)
  );
});

// ─── File input & drag-drop ───────────────────────────────────────────────────
document.getElementById('file-input').addEventListener('change', function() {
  if (this.files[0]) window.loadFile(this.files[0]);
  this.value = '';
});
container.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragging'); });
container.addEventListener('dragleave', () => dropZone.classList.remove('dragging'));
container.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragging');
  if (e.dataTransfer.files[0]) window.loadFile(e.dataTransfer.files[0]);
});
dropZone.addEventListener('click', () => document.getElementById('file-input').click());

// ─── Double-click to focus (browser only) ────────────────────────────────────
renderer.domElement.addEventListener('dblclick', e => {
  if (models.length === 0 || renderer.xr.isPresenting) return;
  const rect = renderer.domElement.getBoundingClientRect();
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(
    new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1),
    camera
  );
  const meshes = models.map(e => e.mesh);
  const hits = raycaster.intersectObjects(meshes, true);
  if (hits.length) { controls.target.copy(hits[0].point); controls.update(); }
});

// ─── Model Browser ────────────────────────────────────────────────────────────
let mbModels  = [];   // [{ name, url }]
let mbFuse    = null; // Fuse instance, built after model list loads
let mbFocused = -1;   // keyboard-nav index into current result list

const mbOverlay   = document.getElementById('model-browser');
const mbSearchEl  = document.getElementById('mb-search-input');
const mbResultsEl = document.getElementById('mb-results');
const mbStatusEl  = document.getElementById('mb-status');

// ── Fetch model list once on page load ────────────────────────────────────────
async function fetchModelList() {
  try {
    const res = await fetch(GITHUB_API);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const files = await res.json();
    mbModels = files
      .filter(f => f.type === 'file')
      .map(f => ({ name: f.name, url: RAW_BASE + encodeURIComponent(f.name) }));

    // Build Fuse.js index on the raw filename exactly as-is
    mbFuse = new Fuse(mbModels, {
      keys: ['name'],
      threshold: 0.4,       // 0=exact match, 1=match anything; 0.4 is forgiving but not noisy
      distance: 200,        // allow match indices spread across a long filename
      minMatchCharLength: 3,
      includeScore: true,
      includeMatches: true, // needed for character-level highlight indices
    });

    mbStatusEl.textContent = mbModels.length + ' models available — type to search';
    mbResultsEl.innerHTML = '';
  } catch (err) {
    mbStatusEl.textContent = 'Could not load model list — check internet connection';
    mbResultsEl.innerHTML = '<div class="mb-empty">GitHub API unavailable.<br>Try the URL loader instead.</div>';
    console.warn('Model list fetch failed:', err);
  }
}
fetchModelList();

// ── Open / close ──────────────────────────────────────────────────────────────
window.openModelBrowser = function() {
  if (renderer.xr.isPresenting) return; // no browser UI while in headset
  mbOverlay.classList.add('open');
  mbSearchEl.value = '';
  mbFocused = -1;
  renderResults([]);
  mbStatusEl.textContent = mbModels.length
    ? mbModels.length + ' models available — type to search'
    : 'Loading model list…';
  requestAnimationFrame(() => mbSearchEl.focus());
};

window.closeModelBrowser = function() {
  mbOverlay.classList.remove('open');
};

// Close on backdrop click
mbOverlay.addEventListener('click', e => { if (e.target === mbOverlay) closeModelBrowser(); });

// Keyboard navigation
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && mbOverlay.classList.contains('open')) {
    closeModelBrowser();
    return;
  }
  if (!mbOverlay.classList.contains('open')) return;
  const items = mbResultsEl.querySelectorAll('.mb-result');
  if (!items.length) return;
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    mbFocused = Math.min(mbFocused + 1, items.length - 1);
    updateFocus(items);
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    mbFocused = Math.max(mbFocused - 1, 0);
    updateFocus(items);
  } else if (e.key === 'Enter' && mbFocused >= 0 && items[mbFocused]) {
    items[mbFocused].querySelector('.mb-load-btn').click();
  }
});

function updateFocus(items) {
  items.forEach((el, i) => el.classList.toggle('focused', i === mbFocused));
  if (items[mbFocused]) items[mbFocused].scrollIntoView({ block: 'nearest' });
}

// ── Search input ──────────────────────────────────────────────────────────────
mbSearchEl.addEventListener('input', () => {
  const q = mbSearchEl.value.trim();
  mbFocused = -1;

  if (q.length < 3) {
    renderResults([]);
    if (q.length === 0) {
      mbStatusEl.textContent = mbModels.length
        ? mbModels.length + ' models available — type to search'
        : 'Loading…';
    } else {
      const need = 3 - q.length;
      mbStatusEl.textContent = need + ' more character' + (need > 1 ? 's' : '') + ' needed…';
    }
    return;
  }

  if (!mbFuse) { mbStatusEl.textContent = 'Model list not ready yet'; return; }

  const results = mbFuse.search(q);
  renderResults(results);
  mbStatusEl.textContent = results.length
    ? results.length + ' match' + (results.length !== 1 ? 'es' : '') + ' for "' + q + '"'
    : 'No matches for "' + q + '"';
});

// ── Render results list ───────────────────────────────────────────────────────
function renderResults(results) {
  if (results.length === 0) {
    const q = mbSearchEl.value.trim();
    mbResultsEl.innerHTML = q.length >= 3
      ? '<div class="mb-empty">No matches for "<b>' + escHtml(q) + '</b>".<br>Try a set number, part of the name,<br>or a different spelling.</div>'
      : '';
    return;
  }

  mbResultsEl.innerHTML = results.map((r, idx) =>
    '<div class="mb-result" data-idx="' + idx + '" data-url="' + escHtml(r.item.url) + '" data-name="' + escHtml(r.item.name) + '">' +
    '<span class="mb-result-name">' + highlightMatches(r.item.name, r.matches) + '</span>' +
    '<button class="mb-load-btn">Load</button>' +
    '</div>'
  ).join('');

  mbResultsEl.querySelectorAll('.mb-result').forEach(el => {
    el.addEventListener('click', () => loadFromBrowser(el.dataset.url, el.dataset.name));
    el.addEventListener('mouseenter', () => {
      mbFocused = parseInt(el.dataset.idx);
      updateFocus(mbResultsEl.querySelectorAll('.mb-result'));
    });
  });
}

// ── Character-level highlight using Fuse match indices ────────────────────────
function highlightMatches(name, matches) {
  if (!matches || !matches.length) return escHtml(name);
  // Collect all matched character positions into a Set
  const marked = new Set();
  for (const m of matches) {
    if (m.key === 'name') {
      for (const [start, end] of m.indices) {
        for (let i = start; i <= end; i++) marked.add(i);
      }
    }
  }
  // Build highlighted HTML character by character
  let html = '', inMark = false;
  for (let i = 0; i < name.length; i++) {
    if (marked.has(i) && !inMark)  { html += '<mark>'; inMark = true; }
    if (!marked.has(i) && inMark)  { html += '</mark>'; inMark = false; }
    html += escHtml(name[i]);
  }
  if (inMark) html += '</mark>';
  return html;
}

function escHtml(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

// ── Load model chosen from browser ────────────────────────────────────────────
function loadFromBrowser(url, name) {
  closeModelBrowser();
  showLoading('Loading model…', name);
  const loader = makeLoader();
  loader.preloadMaterials(PARTS_CDN + 'LDConfig.ldr').catch(() => {}).then(() =>
    loader.load(
      url,
      model => onModelLoaded(model, name),
      xhr  => { if (xhr.total) loadingSub.textContent = 'Downloading… ' + Math.round(xhr.loaded / xhr.total * 100) + '%'; },
      err  => showError('Could not load model.\n\n' + err)
    )
  );
}

</script>
<!-- ─── Model Browser Overlay ─────────────────────────────────────────────── -->
<div id="model-browser">
  <div class="mb-panel">
    <div class="mb-header">
      <span class="mb-title">Browse Official Models</span>
      <button class="mb-close" onclick="closeModelBrowser()" title="Close">✕</button>
    </div>
    <div class="mb-search-wrap">
      <span class="mb-search-icon">⌕</span>
      <input
        type="text"
        class="mb-search"
        id="mb-search-input"
        placeholder="Type 3+ characters to search… (e.g. 7140, AT-ST, xwing)"
        autocomplete="off"
        spellcheck="false"
      >
    </div>
    <div class="mb-status" id="mb-status">Loading model list…</div>
    <div class="mb-results" id="mb-results">
      <div class="mb-loading-indicator">Fetching model list from GitHub…</div>
    </div>
  </div>
</div>
</body>
</html>
